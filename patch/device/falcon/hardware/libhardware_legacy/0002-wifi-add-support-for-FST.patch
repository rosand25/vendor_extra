From 5662d12e4dfc4698c329ed6c11f46dfa16f57978 Mon Sep 17 00:00:00 2001
From: sub77 <darfpunk@gmx.de>
Date: Wed, 21 Dec 2016 07:12:19 +0000
Subject: [PATCH 2/3] wifi: add support for FST

Merge of few commits related to FST support.
Original commits re-worked to remove changes in HAL API.

wifi: generalize ensure_config_file_exists()

ensure_config_file_exists gets config_file_template as argument instead
of using hard-coded SUPP_CONFIG_TEMPLATE.

Change-Id: I52b0c21d47254b5fa62e53ac71552d5dbfc445df

wifi: duplicate wifi.c into wifi_fst.c

Fast Session Transfer (FST) functionality will be added in wifi_fst in
next commit

Change-Id: Id6560ca437da3c9e794b450e10d979270303312b

wifi: introduce wifi_fst module

New wifi_fst module is responsible for:
1. insmod/rmmod of 2nd Wifi driver used for Fast Session Transfer (FST)
rate upgrade.
2. start/stop FST Manager service.

wifi_fst functionality is controlled by system property
persist.fst.rate.upgrade.en.

Existing module wifi.c calls into wifi_fst upon wifi_load/unload_driver
and upon start/stop supplicant

Change-Id: I8b4eddf26ab345b9e1e60e4850eaa081f8b89641
Signed-off-by: sub77 <darfpunk@gmx.de>
---
 wifi/Android.mk |  12 ++-
 wifi/wifi.c     |  34 +++++---
 wifi/wifi_fst.c | 259 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 wifi/wifi_fst.h |  82 ++++++++++++++++++
 4 files changed, 375 insertions(+), 12 deletions(-)
 create mode 100644 wifi/wifi_fst.c
 create mode 100644 wifi/wifi_fst.h

diff --git a/wifi/Android.mk b/wifi/Android.mk
index ba82e8b..7144d8d 100644
--- a/wifi/Android.mk
+++ b/wifi/Android.mk
@@ -41,7 +41,17 @@ ifdef WIFI_DRIVER_STATE_OFF
 LOCAL_CFLAGS += -DWIFI_DRIVER_STATE_OFF=\"$(WIFI_DRIVER_STATE_OFF)\"
 endif
 
-LOCAL_SRC_FILES += wifi/wifi.c
+ifdef WIFI_FST_DRIVER_MODULE_PATH
+LOCAL_CFLAGS += -DWIFI_FST_DRIVER_MODULE_PATH=\"$(WIFI_FST_DRIVER_MODULE_PATH)\"
+endif
+ifdef WIFI_FST_DRIVER_MODULE_ARG
+LOCAL_CFLAGS += -DWIFI_FST_DRIVER_MODULE_ARG=\"$(WIFI_FST_DRIVER_MODULE_ARG)\"
+endif
+ifdef WIFI_FST_DRIVER_MODULE_NAME
+LOCAL_CFLAGS += -DWIFI_FST_DRIVER_MODULE_NAME=\"$(WIFI_FST_DRIVER_MODULE_NAME)\"
+endif
+
+LOCAL_SRC_FILES += wifi/wifi.c wifi/wifi_fst.c
 
 ifeq ($(BOARD_HAVE_SAMSUNG_WIFI),true)
 LOCAL_CFLAGS += -DSAMSUNG_WIFI
diff --git a/wifi/wifi.c b/wifi/wifi.c
index e18cca1..988b00d 100644
--- a/wifi/wifi.c
+++ b/wifi/wifi.c
@@ -37,6 +37,7 @@
 
 #include <sys/syscall.h>
 #include "hardware_legacy/wifi.h"
+#include "wifi_fst.h"
 #ifdef LIBWPA_CLIENT_EXISTS
 #include "libwpa_client/wpa_ctrl.h"
 #endif
@@ -190,7 +191,7 @@ char* get_samsung_wifi_type()
 }
 #endif
 
-static int insmod(const char *filename, const char *args)
+int insmod(const char *filename, const char *args)
 {
      /* O_NOFOLLOW is removed as wlan.ko is symlink pointing to
         the vendor specfic file which is in readonly location */
@@ -207,7 +208,7 @@ static int insmod(const char *filename, const char *args)
      return rc;
 }
 
-static int rmmod(const char *modname)
+int rmmod(const char *modname)
 {
     int ret = -1;
     int maxtry = 10;
@@ -298,7 +299,7 @@ int is_wifi_driver_loaded() {
     while ((fgets(line, sizeof(line), proc)) != NULL) {
         if (strncmp(line, DRIVER_MODULE_TAG, strlen(DRIVER_MODULE_TAG)) == 0) {
             fclose(proc);
-            return 1;
+            return is_fst_driver_loaded();
         }
     }
     fclose(proc);
@@ -349,7 +350,7 @@ int wifi_load_driver()
     while (count-- > 0) {
         if (property_get(DRIVER_PROP_NAME, driver_status, NULL)) {
             if (strcmp(driver_status, "ok") == 0)
-                return 0;
+                return wifi_fst_load_driver();
             else if (strcmp(driver_status, "failed") == 0) {
                 wifi_unload_driver();
                 return -1;
@@ -377,6 +378,9 @@ int wifi_load_driver()
 int wifi_unload_driver()
 {
     usleep(200000); /* allow to finish interface down */
+
+    wifi_fst_unload_driver();
+
 #ifdef WIFI_DRIVER_MODULE_PATH
     if (rmmod(DRIVER_MODULE_NAME) == 0) {
         int count = 20; /* wait at most 10 seconds for completion */
@@ -448,7 +452,7 @@ int ensure_entropy_file_exists()
     return 0;
 }
 
-int ensure_config_file_exists(const char *config_file)
+int ensure_config_file_exists(const char *config_file, const char *config_file_template)
 {
     char buf[2048];
     int srcfd, destfd;
@@ -469,9 +473,9 @@ int ensure_config_file_exists(const char *config_file)
         return -1;
     }
 
-    srcfd = TEMP_FAILURE_RETRY(open(SUPP_CONFIG_TEMPLATE, O_RDONLY));
+    srcfd = TEMP_FAILURE_RETRY(open(config_file_template, O_RDONLY));
     if (srcfd < 0) {
-        ALOGE("Cannot open \"%s\": %s", SUPP_CONFIG_TEMPLATE, strerror(errno));
+        ALOGE("Cannot open \"%s\": %s", config_file_template, strerror(errno));
         return -1;
     }
 
@@ -484,7 +488,7 @@ int ensure_config_file_exists(const char *config_file)
 
     while ((nread = TEMP_FAILURE_RETRY(read(srcfd, buf, sizeof(buf)))) != 0) {
         if (nread < 0) {
-            ALOGE("Error reading \"%s\": %s", SUPP_CONFIG_TEMPLATE, strerror(errno));
+            ALOGE("Error reading \"%s\": %s", config_file_template, strerror(errno));
             close(srcfd);
             close(destfd);
             unlink(config_file);
@@ -735,12 +739,16 @@ int wifi_start_supplicant(int p2p_supported)
     const prop_info *pi;
     unsigned serial = 0, i;
 
+    if (wifi_start_fstman(0)) {
+        return -1;
+    }
+
     if (p2p_supported) {
         strcpy(supplicant_name, P2P_SUPPLICANT_NAME);
         strcpy(supplicant_prop_name, P2P_PROP_NAME);
 
         /* Ensure p2p config file is created */
-        if (ensure_config_file_exists(P2P_CONFIG_FILE) < 0) {
+        if (ensure_config_file_exists(P2P_CONFIG_FILE, SUPP_CONFIG_TEMPLATE) < 0) {
             ALOGE("Failed to create a p2p config file");
             return -1;
         }
@@ -757,7 +765,7 @@ int wifi_start_supplicant(int p2p_supported)
     }
 
     /* Before starting the daemon, make sure its config file exists */
-    if (ensure_config_file_exists(SUPP_CONFIG_FILE) < 0) {
+    if (ensure_config_file_exists(SUPP_CONFIG_FILE, SUPP_CONFIG_TEMPLATE) < 0) {
         ALOGE("Wi-Fi will not be enabled");
         return -1;
     }
@@ -833,6 +841,7 @@ int wifi_stop_supplicant(int p2p_supported)
     /* Check whether supplicant already stopped */
     if (property_get(supplicant_prop_name, supp_status, NULL)
         && strcmp(supp_status, "stopped") == 0) {
+        wifi_stop_fstman(0);
         return 0;
     }
 
@@ -848,12 +857,15 @@ int wifi_stop_supplicant(int p2p_supported)
 
     while (count-- > 0) {
         if (property_get(supplicant_prop_name, supp_status, NULL)) {
-            if (strcmp(supp_status, "stopped") == 0)
+            if (strcmp(supp_status, "stopped") == 0) {
+                wifi_stop_fstman(0);
                 return 0;
+            }
         }
         usleep(100000);
     }
     ALOGE("Failed to stop supplicant");
+    wifi_stop_fstman(0);
     return -1;
 }
 
diff --git a/wifi/wifi_fst.c b/wifi/wifi_fst.c
new file mode 100644
index 0000000..4c362f9
--- /dev/null
+++ b/wifi/wifi_fst.c
@@ -0,0 +1,259 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution.
+ * Copyright 2008, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#define LOG_TAG "WifiFST"
+#include "cutils/log.h"
+#include "cutils/properties.h"
+
+#define _REALLY_INCLUDE_SYS__SYSTEM_PROPERTIES_H_
+#include <sys/_system_properties.h>
+
+#include "hardware_legacy/wifi.h"
+
+#ifndef WIFI_FST_DRIVER_MODULE_PATH
+#define WIFI_FST_DRIVER_MODULE_PATH ""
+#endif
+#ifndef WIFI_FST_DRIVER_MODULE_ARG
+#define WIFI_FST_DRIVER_MODULE_ARG ""
+#endif
+#ifndef WIFI_FST_DRIVER_MODULE_NAME
+#define WIFI_FST_DRIVER_MODULE_NAME ""
+#endif
+
+static const char WIFI_FST_DRIVER_MODULE_TAG[] = WIFI_FST_DRIVER_MODULE_NAME " ";
+static const char FST_DRIVER_PROP_NAME[] = "wlan.fst.driver.status";
+
+static const char FSTMAN_IFNAME[] = "wlan0";
+static const char FSTMAN_NAME[] = "fstman";
+static const char FSTMAN_START_PROP_NAME[] = "netd.fstman.start";
+static const char FSTMAN_CONFIG_TEMPLATE[] = "/system/etc/wifi/fstman.ini";
+static const char FSTMAN_CONFIG_FILE[] = "/data/misc/wifi/fstman.ini";
+static const char FST_RATE_UPGRADE_ENABLED_PROP_NAME[] = "persist.fst.rate.upgrade.en";
+static const char FST_SOFTAP_ENABLED_PROP_NAME[] = "persist.fst.softap.en";
+
+static const char MODULE_FILE[] = "/proc/modules";
+
+#if __cplusplus
+extern "C" {
+#endif
+
+extern int insmod(const char *filename, const char *args);
+extern int rmmod(const char *modname);
+extern int ensure_config_file_exists(const char *config_file, const char *config_file_template);
+
+#if __cplusplus
+};  // extern "C"
+#endif
+
+int is_fst_enabled()
+{
+    char prop_value[PROPERTY_VALUE_MAX] = { '\0' };
+
+    if (property_get(FST_RATE_UPGRADE_ENABLED_PROP_NAME, prop_value, NULL) &&
+        strcmp(prop_value, "1") == 0) {
+        return 1;
+    }
+
+    return 0;
+}
+
+int is_fst_softap_enabled() {
+    char prop_value[PROPERTY_VALUE_MAX] = { '\0' };
+
+    if (is_fst_enabled() &&
+        property_get(FST_SOFTAP_ENABLED_PROP_NAME, prop_value, NULL) &&
+        strcmp(prop_value, "1") == 0) {
+        return 1;
+    }
+
+    return 0;
+}
+
+int is_fst_driver_loaded()
+{
+    char driver_status[PROPERTY_VALUE_MAX];
+    FILE *proc;
+    char line[sizeof(WIFI_FST_DRIVER_MODULE_TAG)+10];
+
+    if (!is_fst_enabled())
+        return 1;
+
+    if (!property_get(FST_DRIVER_PROP_NAME, driver_status, NULL) ||
+        strcmp(driver_status, "ok") != 0)
+        return 0;  /* driver not loaded */
+
+    /*
+    * If the property says the driver is loaded, check to
+    * make sure that the property setting isn't just left
+    * over from a previous manual shutdown or a runtime
+    * crash.
+    */
+    if ((proc = fopen(MODULE_FILE, "r")) == NULL) {
+        ALOGW("Could not open %s: %s", MODULE_FILE, strerror(errno));
+        property_set(FST_DRIVER_PROP_NAME, "unloaded");
+        return 0;
+    }
+    while ((fgets(line, sizeof(line), proc)) != NULL)
+        if (strncmp(line, WIFI_FST_DRIVER_MODULE_TAG,
+                strlen(WIFI_FST_DRIVER_MODULE_TAG)) == 0) {
+            fclose(proc);
+            return 1;
+        }
+
+    fclose(proc);
+    property_set(FST_DRIVER_PROP_NAME, "unloaded");
+    return 0;
+}
+
+int wifi_fst_load_driver()
+{
+    if (!is_fst_enabled())
+        return 0;
+
+    if (is_fst_driver_loaded())
+        return 0;
+
+    if (insmod(WIFI_FST_DRIVER_MODULE_PATH, WIFI_FST_DRIVER_MODULE_ARG) < 0)
+        return -1;
+
+    property_set(FST_DRIVER_PROP_NAME, "ok");
+
+    return 0;
+}
+
+int wifi_fst_unload_driver()
+{
+    int count = 20; /* wait at most 10 seconds for completion */
+
+    if (!is_fst_enabled())
+        return 0;
+
+    if (rmmod(WIFI_FST_DRIVER_MODULE_NAME) != 0)
+        return -1;
+
+    while (count-- > 0) {
+        if (!is_fst_driver_loaded())
+            break;
+        usleep(500000);
+    }
+    usleep(500000); /* allow card removal */
+    if (count)
+        return 0;
+
+    return -1;
+}
+
+static void get_fstman_props(int softap_mode,
+			     char *fstman_svc_name, int fstman_svc_name_len,
+			     char *fstman_init_prop, int fstman_init_prop_len)
+{
+    if (softap_mode)
+        strlcpy(fstman_svc_name, FSTMAN_NAME, fstman_svc_name_len);
+    else
+        snprintf(fstman_svc_name, fstman_svc_name_len, "%s_%s",
+                 FSTMAN_NAME, FSTMAN_IFNAME);
+    snprintf(fstman_init_prop, fstman_init_prop_len, "init.svc.%s",
+             fstman_svc_name);
+}
+
+int wifi_start_fstman(int softap_mode)
+{
+    char fstman_status[PROPERTY_VALUE_MAX] = { '\0' };
+    char fstman_svc_name[PROPERTY_VALUE_MAX] = { '\0' };
+    char fstman_init_prop[PROPERTY_VALUE_MAX] = { '\0' };
+    int count = 50; /* wait at most 5 seconds for completion */
+
+    if (!is_fst_enabled())
+        return 0;
+
+    if (ensure_config_file_exists(FSTMAN_CONFIG_FILE, FSTMAN_CONFIG_TEMPLATE) < 0) {
+        ALOGE("Failed to create fstman config file");
+        return -1;
+    }
+
+    get_fstman_props(softap_mode, fstman_svc_name, sizeof(fstman_svc_name),
+                     fstman_init_prop, sizeof(fstman_init_prop));
+
+    /* Check whether already running */
+    if (property_get(fstman_init_prop, fstman_status, NULL) &&
+        strcmp(fstman_status, "running") == 0)
+        return 0;
+
+    ALOGD("Starting FST Manager");
+    /* when invoked from netd, use different property because of different
+       selinux permissions */
+    if (softap_mode) {
+        property_set(FSTMAN_START_PROP_NAME, "true");
+    } else {
+        property_set("ctl.start", fstman_svc_name);
+    }
+    sched_yield();
+
+    while (count-- > 0) {
+        if (property_get(fstman_init_prop, fstman_status, NULL) &&
+            strcmp(fstman_status, "running") == 0)
+                return 0;
+        usleep(100000);
+    }
+
+    ALOGE("Failed to start FST Manager");
+    return -1;
+}
+
+int wifi_stop_fstman(int softap_mode)
+{
+    char fstman_status[PROPERTY_VALUE_MAX] = { '\0' };
+    char fstman_svc_name[PROPERTY_VALUE_MAX] = { '\0' };
+    char fstman_init_prop[PROPERTY_VALUE_MAX] = { '\0' };
+    int count = 50; /* wait at most 5 seconds for completion */
+
+    if (!is_fst_enabled())
+        return 0;
+
+    get_fstman_props(softap_mode, fstman_svc_name, sizeof(fstman_svc_name),
+                     fstman_init_prop, sizeof(fstman_init_prop));
+
+    /* Check whether already stopped */
+    if (property_get(fstman_init_prop, fstman_status, NULL) &&
+        strcmp(fstman_status, "stopped") == 0)
+        return 0;
+
+    ALOGD("Stopping FST Manager");
+    /* when invoked from netd, use different property because of different
+       selinux permissions */
+    if (softap_mode)
+        property_set(FSTMAN_START_PROP_NAME, "false");
+    else
+        property_set("ctl.stop", fstman_svc_name);
+    sched_yield();
+
+    while (count-- > 0) {
+        if (property_get(fstman_init_prop, fstman_status, NULL) &&
+            strcmp(fstman_status, "stopped") == 0)
+                return 0;
+        usleep(100000);
+    }
+
+    ALOGE("Failed to stop fstman");
+    return -1;
+}
diff --git a/wifi/wifi_fst.h b/wifi/wifi_fst.h
new file mode 100644
index 0000000..952f132
--- /dev/null
+++ b/wifi/wifi_fst.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Not a Contribution.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _WIFI_FST_H
+#define _WIFI_FST_H
+
+#if __cplusplus
+extern "C" {
+#endif
+
+/**
+ * returns whether FST is enabled or not according to
+ * persist.fst.rate.upgrade.en system property
+ *
+ * @return 1 if FST enabled.
+ */
+int is_fst_enabled();
+
+/**
+* returns whether FST Soft AP is enabled or not according to
+* persist.fst.softap.en system property
+*
+* @return 1 if FST Soft AP enabled.
+*/
+int is_fst_softap_enabled();
+
+/**
+ * Load the Wi-Fi driver for FST rate upgrade.
+ *
+ * @return 0 on success, < 0 on failure.
+ */
+int wifi_fst_load_driver();
+
+/**
+ * Unload the Wi-Fi driver for FST rate upgrade.
+ *
+ * @return 0 on success, < 0 on failure.
+ */
+int wifi_fst_unload_driver();
+
+/**
+ * Check if the Wi-Fi driver for FST rate upgrade is loaded.
+
+ * @return 0 on success, < 0 on failure.
+ */
+int is_fst_driver_loaded();
+
+/**
+ * Start FST Manager.
+ *
+ * @return 0 on success, < 0 on failure.
+ */
+int wifi_start_fstman(int softap_mode);
+
+/**
+ * Stop FST Manager.
+ *
+ * @return 0 on success, < 0 on failure.
+ */
+int wifi_stop_fstman(int softap_mode);
+
+#if __cplusplus
+};  // extern "C"
+#endif
+
+#endif  // _WIFI_FST_H
-- 
2.1.4

