From 7fa206bcb0b22399c1c68226e2889d93250958d8 Mon Sep 17 00:00:00 2001
From: 0xD34D <clark@scheffsblend.com>
Date: Tue, 15 Nov 2016 03:39:53 -0500
Subject: [PATCH 16/16] OMS7-N: Load missing style attributes from original
 style

If a theme overrides a style in an app and does not include all
the attributes found in the original, it is possible for the app
to crash because it cannot locate an attribute it is expecting.

To overcome this we need to check the attributes in the original
style's bag and add any missing attributes to the current bag being
populated.  Currently we have only seen one theme that causes this
behavior, but there could be others out there or we may eventually
see this happen in the wild as apps update and the themes have not
had a chance to incorporate the new additions from the app.

Signed-off-by: sub77 <sub77@ymail.com>
---
 libs/androidfw/ResourceTypes.cpp | 61 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 60 insertions(+), 1 deletion(-)

diff --git a/libs/androidfw/ResourceTypes.cpp b/libs/androidfw/ResourceTypes.cpp
index 3479cba..00b79bd 100644
--- a/libs/androidfw/ResourceTypes.cpp
+++ b/libs/androidfw/ResourceTypes.cpp
@@ -3146,6 +3146,8 @@ struct ResTable::Entry {
 
     StringPoolRef typeStr;
     StringPoolRef keyStr;
+
+    bool isFromOverlay;
 };
 
 struct ResTable::Type
@@ -4408,6 +4410,62 @@ ssize_t ResTable::getBagLocked(uint32_t resID, const bag_entry** outBag,
         set->numAttrs = curEntry;
     }
 
+    // If this style was overridden by a theme then we need to compare our bag with
+    // the bag from the original and add any missing attributes to our bag
+    if (entry.isFromOverlay) {
+        const bag_entry* originalBag;
+        uint32_t originalTypeSpecFlags = 0;
+        const ssize_t NO = getBagLocked(resID, &originalBag,
+                &originalTypeSpecFlags);
+        if (NO <= 0) {
+            ALOGW("Failed to retrieve original bag for 0x%08x", resID);
+        }
+
+        // Now merge in the original attributes...
+        bag_entry* entries = (bag_entry*)(set+1);
+        size_t curEntry = 0;
+        for (int i = 0; i < NO; i++) {
+            const uint32_t newName = originalBag[i].map.name.ident;
+            bool isInside;
+            uint32_t oldName = 0;
+            curEntry = 0;
+
+            while ((isInside=(curEntry < set->numAttrs))
+                    && (oldName=entries[curEntry].map.name.ident) < newName) {
+                curEntry++;
+            }
+
+            if ((!isInside) || oldName != newName) {
+                // This is a new attribute...  figure out what to do with it.
+                // Need to alloc more memory...
+                size_t prevEntry = curEntry;
+                curEntry = set->availAttrs;
+                set->availAttrs++;
+                const size_t newAvail = set->availAttrs;
+                set = (bag_set*)realloc(set,
+                                        sizeof(bag_set)
+                                        + sizeof(bag_entry)*newAvail);
+                if (set == NULL) {
+                    return NO_MEMORY;
+                }
+                entries = (bag_entry*)(set+1);
+                if (isInside) {
+                    // Going in the middle, need to make space.
+                    memmove(entries+prevEntry+1, entries+prevEntry,
+                            sizeof(bag_entry)*(set->numAttrs-prevEntry));
+                }
+
+                bag_entry* cur = entries+curEntry;
+
+                cur->stringBlock = originalBag[i].stringBlock;
+                cur->map.name.ident = originalBag[i].map.name.ident;
+                cur->map.value = originalBag[i].map.value;
+                set->typeSpecFlags |= originalTypeSpecFlags;
+                set->numAttrs = set->availAttrs;
+            }
+        }
+    }
+
     // And this is it...
     typeSet[e] = set;
     if (set) {
@@ -5979,6 +6037,7 @@ status_t ResTable::getEntry(
     uint8_t actualTypeIndex = typeIndex;
     ResTable_config bestConfig;
     memset(&bestConfig, 0, sizeof(bestConfig));
+    bool currentTypeIsOverlay = false;
 
     // Iterate over the Types of each package.
     const size_t typeCount = typeList.size();
@@ -5987,7 +6046,6 @@ status_t ResTable::getEntry(
 
         int realEntryIndex = entryIndex;
         int realTypeIndex = typeIndex;
-        bool currentTypeIsOverlay = false;
 
         // Runtime overlay packages provide a mapping of app resource
         // ID to package resource ID.
@@ -6121,6 +6179,7 @@ status_t ResTable::getEntry(
         outEntry->package = bestPackage;
         outEntry->typeStr = StringPoolRef(&bestPackage->typeStrings, actualTypeIndex - bestPackage->typeIdOffset);
         outEntry->keyStr = StringPoolRef(&bestPackage->keyStrings, dtohl(entry->key.index));
+        outEntry->isFromOverlay = currentTypeIsOverlay;
     }
     return NO_ERROR;
 }
-- 
2.1.4

