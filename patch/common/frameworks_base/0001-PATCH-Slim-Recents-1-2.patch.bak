From ac2a81ccaefd0c053b6c1106d9c0cf1b0914e065 Mon Sep 17 00:00:00 2001
From: sub77 <sub77@ymail.com>
Date: Mon, 20 Mar 2017 14:47:19 +0000
Subject: [PATCH 1/3] [PATCH] Slim Recents [1/2]

* Credits to SlimRoms, maxwen, kufikugel
* Thanks to ezio for new fixes

Change-Id: I679b16ffc094258d46b91cf81baa0b843c563fb2
Signed-off-by: Pranav Vashi <neobuddy89@gmail.com>
---
 core/java/android/provider/Settings.java           |   56 ++
 core/java/android/view/WindowManager.java          |    6 +
 core/res/res/anim/recent_screen_enter.xml          |   22 +
 core/res/res/anim/recent_screen_enter_left.xml     |   22 +
 core/res/res/anim/recent_screen_exit.xml           |   22 +
 core/res/res/anim/recent_screen_exit_left.xml      |   22 +
 core/res/res/anim/recent_screen_fade_out.xml       |   21 +
 core/res/res/drawable/ic_global_dnd_off.xml        |    2 +
 core/res/res/values/custom_config.xml              |    6 +
 core/res/res/values/custom_styles.xml              |   12 +
 core/res/res/values/custom_symbols.xml             |    9 +
 core/res/res/values/custom_symbols.xml.orig        |  122 +++
 packages/SystemUI/Android.mk                       |   13 +-
 packages/SystemUI/res/drawable/ic_done.xml         |   13 +
 packages/SystemUI/res/drawable/ic_empty_recent.xml |   35 +
 packages/SystemUI/res/drawable/ic_multiwindow.xml  |   26 +
 .../SystemUI/res/drawable/ic_recent_app_info.xml   |   24 +
 .../SystemUI/res/drawable/ic_recent_favorite.xml   |   30 +
 .../SystemUI/res/drawable/ic_recent_keyguard.xml   |   15 +
 packages/SystemUI/res/drawable/ic_shop.xml         |   14 +
 packages/SystemUI/res/layout/recent_base_card.xml  |   26 +
 .../res/layout/recent_base_card_layout.xml         |  119 +++
 .../res/layout/recent_base_card_thumbnail.xml      |   35 +
 .../res/layout/recent_inner_card_expand.xml        |   31 +
 packages/SystemUI/res/layout/slim_recent.xml       |   77 ++
 .../SystemUI/res/layout/slim_recent_keyguard.xml   |   49 +
 packages/SystemUI/res/values-land/cr_config.xml    |   23 +
 .../SystemUI/res/values-sw600dp-land/cr_config.xml |   21 +
 packages/SystemUI/res/values/custom_colors.xml     |    5 +
 packages/SystemUI/res/values/custom_dimens.xml     |   11 +
 packages/SystemUI/res/values/custom_strings.xml    |    4 +
 packages/SystemUI/res/values/custom_styles.xml     |   61 ++
 .../android/systemui/slimrecent/AppIconLoader.java |  235 +++++
 .../systemui/slimrecent/CacheController.java       |  326 ++++++
 .../slimrecent/ColorDrawableWithDimensions.java    |   41 +
 .../android/systemui/slimrecent/ColorUtils.java    |   55 ++
 .../android/systemui/slimrecent/RecentAppIcon.java |  119 +++
 .../android/systemui/slimrecent/RecentCard.java    |  360 +++++++
 .../systemui/slimrecent/RecentController.java      |  925 +++++++++++++++++
 .../systemui/slimrecent/RecentExpandedCard.java    |  387 ++++++++
 .../android/systemui/slimrecent/RecentHeader.java  |  160 +++
 .../systemui/slimrecent/RecentImageView.java       |   86 ++
 .../systemui/slimrecent/RecentPanelView.java       | 1034 ++++++++++++++++++++
 .../systemui/slimrecent/TaskDescription.java       |   94 ++
 .../systemui/slimrecent/UserContentObserver.java   |   95 ++
 .../android/systemui/statusbar/BaseStatusBar.java  |   50 +-
 .../statusbar/phone/KeyguardStatusBarView.java     |    1 +
 .../systemui/statusbar/phone/PhoneStatusBar.java   |   28 +-
 .../android/server/policy/PhoneWindowManager.java  |    2 +
 .../android/server/wm/WindowManagerService.java    |    3 +-
 50 files changed, 4941 insertions(+), 14 deletions(-)
 create mode 100644 core/res/res/anim/recent_screen_enter.xml
 create mode 100644 core/res/res/anim/recent_screen_enter_left.xml
 create mode 100644 core/res/res/anim/recent_screen_exit.xml
 create mode 100644 core/res/res/anim/recent_screen_exit_left.xml
 create mode 100644 core/res/res/anim/recent_screen_fade_out.xml
 create mode 100644 core/res/res/values/custom_symbols.xml.orig
 create mode 100644 packages/SystemUI/res/drawable/ic_done.xml
 create mode 100644 packages/SystemUI/res/drawable/ic_empty_recent.xml
 create mode 100644 packages/SystemUI/res/drawable/ic_multiwindow.xml
 create mode 100644 packages/SystemUI/res/drawable/ic_recent_app_info.xml
 create mode 100644 packages/SystemUI/res/drawable/ic_recent_favorite.xml
 create mode 100644 packages/SystemUI/res/drawable/ic_recent_keyguard.xml
 create mode 100644 packages/SystemUI/res/drawable/ic_shop.xml
 create mode 100644 packages/SystemUI/res/layout/recent_base_card.xml
 create mode 100644 packages/SystemUI/res/layout/recent_base_card_layout.xml
 create mode 100644 packages/SystemUI/res/layout/recent_base_card_thumbnail.xml
 create mode 100644 packages/SystemUI/res/layout/recent_inner_card_expand.xml
 create mode 100644 packages/SystemUI/res/layout/slim_recent.xml
 create mode 100644 packages/SystemUI/res/layout/slim_recent_keyguard.xml
 create mode 100644 packages/SystemUI/res/values-land/cr_config.xml
 create mode 100644 packages/SystemUI/res/values-sw600dp-land/cr_config.xml
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/AppIconLoader.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/CacheController.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/ColorDrawableWithDimensions.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/ColorUtils.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentAppIcon.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentCard.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentController.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentExpandedCard.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentHeader.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentImageView.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/RecentPanelView.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/TaskDescription.java
 create mode 100644 packages/SystemUI/src/com/android/systemui/slimrecent/UserContentObserver.java

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index a75abff2f35..38ddb7a599a 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4064,6 +4064,62 @@ public final class Settings {
         public static final String HEADS_UP_NOTIFICATIONS_USER_ENABLED = "heads_up_notifications_user_enabled";
 
         /**
+         * Whether to use slim recents
+         * @hide
+         */
+        public static final String USE_SLIM_RECENTS = "use_slim_recents";
+
+        /**
+         * Whether to only show actually running tasks
+         * @hide
+         */
+        public static final String RECENT_SHOW_RUNNING_TASKS = "show_running_tasks";
+
+        /**
+         * Amount of apps to show in recents
+         * @hide
+         */
+        public static final String RECENTS_MAX_APPS = "recents_max_apps";
+
+        /**
+         * Whether recent panel gravity is left or right (default = Gravity.RIGHT).
+         * @hide
+         */
+        public static final String RECENT_PANEL_GRAVITY = "recent_panel_gravity";
+
+        /**
+         * Size of recent panel view in percent (default = 100).
+         * @hide
+         */
+        public static final String RECENT_PANEL_SCALE_FACTOR = "recent_panel_scale_factor";
+
+        /**
+         * User favorite tasks for recent panel.
+         * @hide
+         */
+        public static final String RECENT_PANEL_FAVORITES = "recent_panel_favorites";
+
+        /**
+         * Recent panel expanded mode (auto = 0, always = 1, never = 2).
+         * default = 0.
+         *
+         * @hide
+         */
+        public static final String RECENT_PANEL_EXPANDED_MODE = "recent_panel_expanded_mode";
+
+        /**
+         * Recent panel: Show topmost task
+         * @hide
+         */
+        public static final String RECENT_PANEL_SHOW_TOPMOST = "recent_panel_show_topmost";
+
+        /**
+         * Recent panel background color
+         * @hide
+         */
+        public static final String RECENT_PANEL_BG_COLOR = "recent_panel_bg_color";
+
+        /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
          *
diff --git a/core/java/android/view/WindowManager.java b/core/java/android/view/WindowManager.java
index 395f73844b0..1f15693645f 100644
--- a/core/java/android/view/WindowManager.java
+++ b/core/java/android/view/WindowManager.java
@@ -651,6 +651,12 @@ public interface WindowManager extends ViewManager {
         public static final int TYPE_SCREENSHOT = FIRST_SYSTEM_WINDOW + 36;
 
         /**
+         * Window type: panel that slides out from the status bar
+         * In multiuser systems shows on all users' windows.
+         */
+        public static final int TYPE_SLIM_RECENTS      = FIRST_SYSTEM_WINDOW+37;
+
+        /**
          * End of types of system windows.
          */
         public static final int LAST_SYSTEM_WINDOW      = 2999;
diff --git a/core/res/res/anim/recent_screen_enter.xml b/core/res/res/anim/recent_screen_enter.xml
new file mode 100644
index 00000000000..f2b3891393e
--- /dev/null
+++ b/core/res/res/anim/recent_screen_enter.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/decelerate_interpolator">
+    <translate android:fromXDelta="100%p" android:toXDelta="0"
+        android:duration="@android:integer/config_recentDefaultDur"/>
+</set>
diff --git a/core/res/res/anim/recent_screen_enter_left.xml b/core/res/res/anim/recent_screen_enter_left.xml
new file mode 100644
index 00000000000..183fdeed04a
--- /dev/null
+++ b/core/res/res/anim/recent_screen_enter_left.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/decelerate_interpolator">
+    <translate android:fromXDelta="-100%p" android:toXDelta="0"
+        android:duration="@android:integer/config_recentDefaultDur"/>
+</set>
diff --git a/core/res/res/anim/recent_screen_exit.xml b/core/res/res/anim/recent_screen_exit.xml
new file mode 100644
index 00000000000..7ec79e00fa6
--- /dev/null
+++ b/core/res/res/anim/recent_screen_exit.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/decelerate_interpolator">
+    <translate android:fromXDelta="0" android:toXDelta="100%p"
+        android:duration="@android:integer/config_recentExitDur"/>
+</set>
diff --git a/core/res/res/anim/recent_screen_exit_left.xml b/core/res/res/anim/recent_screen_exit_left.xml
new file mode 100644
index 00000000000..5a735fff3af
--- /dev/null
+++ b/core/res/res/anim/recent_screen_exit_left.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android"
+    android:interpolator="@android:anim/decelerate_interpolator">
+    <translate android:fromXDelta="0" android:toXDelta="-100%p"
+        android:duration="@android:integer/config_recentExitDur"/>
+</set>
diff --git a/core/res/res/anim/recent_screen_fade_out.xml b/core/res/res/anim/recent_screen_fade_out.xml
new file mode 100644
index 00000000000..f46777c8d70
--- /dev/null
+++ b/core/res/res/anim/recent_screen_fade_out.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<set xmlns:android="http://schemas.android.com/apk/res/android">
+    <alpha android:fromAlpha="1.0" android:toAlpha="0.0"
+        android:duration="@android:integer/config_recentDefaultDur" />
+</set>
diff --git a/core/res/res/drawable/ic_global_dnd_off.xml b/core/res/res/drawable/ic_global_dnd_off.xml
index 6c1f6e2b851..93a767e2771 100644
--- a/core/res/res/drawable/ic_global_dnd_off.xml
+++ b/core/res/res/drawable/ic_global_dnd_off.xml
@@ -22,3 +22,5 @@
     <item android:drawable="@drawable/ic_global_dnd_off_tint" />
 </selector>
 
+    <!-- Default value how much apps show the app screenshot on recents view entry -->
+    <integer name="expanded_items_default">3</integer>
diff --git a/core/res/res/values/custom_config.xml b/core/res/res/values/custom_config.xml
index 1c1f36e460c..2fbd109084c 100644
--- a/core/res/res/values/custom_config.xml
+++ b/core/res/res/values/custom_config.xml
@@ -105,4 +105,10 @@
     <string name="operator_ping_url" translatable="false"></string>
     <!-- Zero Balance feature enable config -->
     <bool name="config_zero_balance_operator">false</bool>
+
+    <!-- The duration (in milliseconds) of recent app screen animation. -->
+    <integer name="config_recentDefaultDur">300</integer>
+
+    <!-- The duration (in milliseconds) of recent app screen exit animation. -->
+    <integer name="config_recentExitDur">450</integer>
 </resources>
diff --git a/core/res/res/values/custom_styles.xml b/core/res/res/values/custom_styles.xml
index 2a612b7ccfe..49489171893 100644
--- a/core/res/res/values/custom_styles.xml
+++ b/core/res/res/values/custom_styles.xml
@@ -30,4 +30,16 @@
         <item name="windowEnterAnimation">@anim/dialog_enter</item>
         <item name="windowExitAnimation">@anim/dialog_exit</item>
     </style>
+    <!-- Slim recent app screen animation -->
+    <style name="Animation" />
+
+    <style name="Animation.RecentScreen">
+        <item name="android:windowEnterAnimation">@anim/recent_screen_enter</item>
+        <item name="android:windowExitAnimation">@anim/recent_screen_exit</item>
+    </style>
+
+    <style name="Animation.RecentScreen.Left">
+        <item name="android:windowEnterAnimation">@anim/recent_screen_enter_left</item>
+        <item name="android:windowExitAnimation">@anim/recent_screen_exit_left</item>
+    </style>
 </resources>
diff --git a/core/res/res/values/custom_symbols.xml b/core/res/res/values/custom_symbols.xml
index 61430291c68..0179a1cb254 100644
--- a/core/res/res/values/custom_symbols.xml
+++ b/core/res/res/values/custom_symbols.xml
@@ -119,4 +119,13 @@
   <java-symbol type="string" name="operator_config_url" />
   <java-symbol type="string" name="operator_ping_url" />
   <java-symbol type="bool" name="config_zero_balance_operator"/>
+
+  <!-- Slim recent app screen-->
+  <java-symbol type="integer" name="config_recentDefaultDur" />
+  <java-symbol type="integer" name="config_recentExitDur" />
+  <java-symbol type="style" name="Animation.RecentScreen" />
+  <java-symbol type="style" name="Animation.RecentScreen.Left" />
+  <java-symbol type="anim" name="recent_screen_enter" />
+  <java-symbol type="anim" name="recent_screen_enter_left" />
+  <java-symbol type="anim" name="recent_screen_fade_out" />
 </resources>
diff --git a/core/res/res/values/custom_symbols.xml.orig b/core/res/res/values/custom_symbols.xml.orig
new file mode 100644
index 00000000000..61430291c68
--- /dev/null
+++ b/core/res/res/values/custom_symbols.xml.orig
@@ -0,0 +1,122 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/* //device/apps/common/assets/res/any/strings.xml
+**
+** Copyright 2006, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+  <java-symbol type="string" name="reboot_title" />
+  <java-symbol type="string" name="reboot_confirm" />
+  <java-symbol type="array" name="config_sms_convert_destination_number_support" />
+  <!-- Power menu reboot -->
+  <java-symbol name="ic_lock_power_reboot" type="drawable" />
+  <java-symbol name="global_action_reboot" type="string" />
+  <java-symbol name="global_action_reboot_sub" type="string" />
+  <java-symbol name="global_action_reboot_more" type="string" />
+  <java-symbol name="global_action_reboot_recovery" type="string" />
+  <java-symbol name="global_action_reboot_bootloader" type="string" />
+  <java-symbol type="array" name="config_rebootActionsList" />
+  <java-symbol type="array" name="values_globalActionsList" />
+  <java-symbol name="reboot_to_bootloader_title" type="string" />
+  <java-symbol name="reboot_to_bootloader_message" type="string" />
+  <java-symbol name="reboot_to_recovery_title" type="string" />
+  <java-symbol name="reboot_to_recovery_message" type="string" />
+  <java-symbol name="reboot_system_title" type="string" />
+  <java-symbol name="reboot_system_message" type="string" />
+  <java-symbol type="drawable" name="ic_global_airplane_mode" />
+  <java-symbol type="drawable" name="ic_global_airplane_mode_off" />
+  <java-symbol type="drawable" name="ic_global_power_off" />
+  <java-symbol name="ic_global_power_rebootbootloader" type="drawable" />
+  <java-symbol name="ic_global_power_rebootrecovery" type="drawable" />
+  <java-symbol name="ic_global_power_reboot" type="drawable" />
+  <java-symbol type="drawable" name="ic_global_audio_ring_notif" />
+  <java-symbol type="drawable" name="ic_global_audio_ring_notif_mute" />
+  <java-symbol type="drawable" name="ic_global_audio_ring_notif_vibrate" />
+  <java-symbol type="drawable" name="ic_global_lock" />
+  <java-symbol type="drawable" name="ic_global_settings" />
+  <java-symbol type="drawable" name="ic_global_voice_search" />
+  <java-symbol type="drawable" name="ic_global_dnd_off" />
+  <java-symbol type="drawable" name="ic_global_dnd_total_silence" />
+  <java-symbol type="drawable" name="ic_global_dnd_alarms" />
+  <java-symbol type="drawable" name="ic_global_dnd_important" />
+  <java-symbol type="drawable" name="ic_global_users" />
+  <java-symbol type="id" name="option4" />
+  <java-symbol type="id" name="global_action_skip" />
+  <java-symbol type="layout" name="global_action_dismissable_dialog" />
+  <java-symbol type="string" name="global_action_dismissable_dialog_text" />
+  <java-symbol type="layout" name="global_actions_dnd_mode" />
+  <!-- global actions -->
+  <java-symbol type="style" name="GlobalActionsAnimation" />
+  <java-symbol type="style" name="GlobalActionsAnimationTop" />
+  <java-symbol type="style" name="GlobalActionsAnimationEnter" />
+  <java-symbol type="string" name="global_action_users" />
+  <java-symbol type="dimen" name="global_actions_avatar_size" />
+  <java-symbol type="color" name="global_actions_icon_color" />
+  <java-symbol type="color" name="global_actions_text_color_dark" />
+  <!-- Vendor image mismatch -->
+  <java-symbol type="string" name="system_error_vendorprint" />
+  <!--OmniGears Battery lights -->
+  <java-symbol type="bool" name="config_multiColorBatteryLed" />
+  <java-symbol type="bool" name="config_intrusiveBatteryLed" />
+  <!-- ScreenRecord -->
+  <java-symbol type="bool" name="config_enableScreenrecordChord" />
+  <java-symbol type="drawable" name="ic_global_screenshot" />
+  <java-symbol type="drawable" name="ic_global_screenshot_white" />
+  <java-symbol type="string" name="global_action_screenshot" />
+  <java-symbol type="drawable" name="ic_global_screenrecord" />
+  <java-symbol type="string" name="global_action_screenrecord" />
+  <java-symbol type="drawable" name="ic_global_torch_on" />
+  <java-symbol type="drawable" name="ic_global_torch_off" />
+  <java-symbol type="string" name="global_action_torch_on" />
+  <java-symbol type="string" name="global_action_torch_off" />
+  <java-symbol type="string" name="global_actions_toggle_torch_mode" />
+
+  <java-symbol type="bool" name="config_button_brightness_support" />
+  <java-symbol type="integer" name="config_button_brightness_default" />
+
+  <java-symbol type="string" name="config_deviceKeyHandlerLib" />
+  <java-symbol type="string" name="config_deviceKeyHandlerClass" />
+
+  <!-- Notification light -->
+  <java-symbol type="bool" name="config_intrusiveNotificationLed" />
+  <java-symbol type="bool" name="config_multiColorNotificationLed" />
+  <java-symbol type="array" name="notification_light_package_mapping" />
+  <java-symbol type="array" name="config_notificationNoAlertsVibePattern" />
+  <!-- LED pulse -->
+  <java-symbol type="bool" name="config_ledCanPulse" />
+
+  <java-symbol type="integer" name="config_deviceHardwareKeys" />
+
+  <java-symbol type="drawable" name="ic_audio_notification_new" />
+  <java-symbol type="drawable" name="ic_audio_notification_mute_new" />
+
+  <!-- back kill -->
+  <java-symbol type="integer" name="config_backKillTimeout" />
+  <java-symbol type="string" name="app_killed_message" />
+
+  <java-symbol type="string" name="lock_to_app_toast_back" />
+
+  <java-symbol type="integer" name="config_longPressOnMenuBehavior" />
+
+  <java-symbol type="bool" name="config_useSystemClockforRotationSensor" />
+  <!-- CAF -->
+  <java-symbol type="string" name="power_key_emergency_number" />
+  <java-symbol type="integer" name="power_key_hits_emergency" />
+  <java-symbol type="bool" name="config_emergencyCallOnPowerkeyTapGestureEnabled" />
+  <java-symbol type="string" name="operator_config_url" />
+  <java-symbol type="string" name="operator_ping_url" />
+  <java-symbol type="bool" name="config_zero_balance_operator"/>
+</resources>
diff --git a/packages/SystemUI/Android.mk b/packages/SystemUI/Android.mk
index ad3c26b29c5..00849695f29 100644
--- a/packages/SystemUI/Android.mk
+++ b/packages/SystemUI/Android.mk
@@ -28,7 +28,10 @@ LOCAL_STATIC_JAVA_LIBRARIES := \
     android-support-v14-preference \
     android-support-v17-leanback \
     framework-protos \
-    SystemUI-proto-tags
+    SystemUI-proto-tags \
+    rebound \
+    android-support-v7-cardview \
+    android-opt-cards
 
 LOCAL_JAVA_LIBRARIES := telephony-common
 
@@ -45,11 +48,15 @@ LOCAL_RESOURCE_DIR := \
     frameworks/support/v14/preference/res \
     frameworks/support/v7/appcompat/res \
     frameworks/support/v7/recyclerview/res \
-    frameworks/support/v17/leanback/res
+    frameworks/support/v17/leanback/res \
+    packages/apps/DUI/res \
+    frameworks/support/v7/cardview/res \
+    frameworks/opt/cards/res
 
 LOCAL_AAPT_FLAGS := --auto-add-overlay \
     --extra-packages com.android.keyguard:android.support.v7.recyclerview:android.support.v7.preference:android.support.v14.preference:android.support.v7.appcompat \
-    --extra-packages android.support.v17.leanback
+    --extra-packages android.support.v17.leanback:android.support.v7.cardview \
+    --extra-packages com.android.cards
 
 ifneq ($(SYSTEM_UI_INCREMENTAL_BUILDS),)
     LOCAL_PROGUARD_ENABLED := disabled
diff --git a/packages/SystemUI/res/drawable/ic_done.xml b/packages/SystemUI/res/drawable/ic_done.xml
new file mode 100644
index 00000000000..b08c85c8695
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_done.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+
+    <path
+        android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="#ffffff"
+        android:pathData="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z" />
+</vector>
diff --git a/packages/SystemUI/res/drawable/ic_empty_recent.xml b/packages/SystemUI/res/drawable/ic_empty_recent.xml
new file mode 100644
index 00000000000..bdcccbe7764
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_empty_recent.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="61.517dp"
+    android:height="75.16dp"
+    android:viewportWidth="61.517"
+    android:viewportHeight="75.16">
+
+    <path
+        android:fillColor="#b3b3b3"
+        android:pathData="M6.5138 75.065c-4.01-0.11-7.03-4.16-6.44-8.05-0.009983-20.16-0.009983-40.32
+0.000017-60.48 0.090003-3.9905 4.07-7.0205 7.94-6.4705 15.73 0.000018
+31.45-0.019982 47.18 0.020018 4.05 0.23 6.85 4.37 6.24 8.24 0.01 5.2005 0.01
+10.4 0.01 15.6l-6.79 0.001v-17.04l-47.83-0.0005c-0.0002 20.46-0.0002
+40.92-0.0202 61.37l47.85 0.001v-17.04h6.79c-0.07 6.14 0.15 12.3-0.15 18.42-0.67
+3.76-4.64 6-8.27 5.44-15.5 0.01-31.01
+0-46.51-0.01zm41.28-28.97v-5.11h-32.95v-6.82h32.95c0.01-3.41 0-6.82 0.01-10.22
+4.55 4.54 9.09 9.08 13.63 13.63-4.54 4.54-9.08 9.09-13.63
+13.63-0.01-1.7-0.01-3.41-0.01-5.11z" />
+</vector>
diff --git a/packages/SystemUI/res/drawable/ic_multiwindow.xml b/packages/SystemUI/res/drawable/ic_multiwindow.xml
new file mode 100644
index 00000000000..bbe31b13472
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_multiwindow.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="24dp"
+        android:height="24dp"
+        android:viewportWidth="24.000002"
+        android:viewportHeight="24.0">
+    <path
+        android:pathData="M3.782,20.988C3.594,20.964 3.417,20.874 3.281,20.733 3.133,20.58 3.063,20.426 3.041,20.204 3.034,20.139 3.032,18.914 3.034,16.644 3.037,13.425 3.039,13.18 3.055,13.116 3.136,12.792 3.371,12.552 3.692,12.467L3.777,12.444 12.002,12.444 20.227,12.444 20.312,12.467C20.469,12.509 20.59,12.577 20.705,12.688 20.824,12.803 20.901,12.938 20.944,13.106L20.967,13.194 20.967,16.719 20.967,20.244 20.944,20.332C20.901,20.5 20.824,20.635 20.705,20.75 20.592,20.859 20.473,20.927 20.317,20.972L20.237,20.994 12.042,20.996C7.534,20.996 3.818,20.993 3.782,20.988ZM18.752,16.719 L18.752,14.689 12.002,14.689 5.252,14.689 5.252,16.719 5.252,18.749 12.002,18.749 18.752,18.749 18.752,16.719ZM3.788,11.549C3.503,11.515 3.24,11.322 3.116,11.056 3.097,11.015 3.072,10.943 3.059,10.897L3.037,10.814 3.034,7.354C3.032,5.087 3.034,3.86 3.041,3.794 3.054,3.669 3.073,3.594 3.116,3.502 3.163,3.402 3.218,3.325 3.298,3.248 3.413,3.137 3.535,3.069 3.692,3.027L3.777,3.004 12.002,3.004 20.227,3.004 20.312,3.027C20.451,3.063 20.589,3.139 20.689,3.233 20.823,3.36 20.899,3.49 20.944,3.666L20.967,3.754 20.967,7.279 20.967,10.804 20.944,10.892C20.903,11.054 20.837,11.172 20.722,11.293 20.614,11.406 20.479,11.486 20.317,11.532L20.237,11.554 12.047,11.556C7.542,11.556 3.826,11.553 3.788,11.549ZM18.752,7.279 L18.752,5.249 12.002,5.249 5.252,5.249 5.252,7.279 5.252,9.309 12.002,9.309 18.752,9.309 18.752,7.279Z"
+        android:fillColor="#FFFFFF"/>
+</vector>
diff --git a/packages/SystemUI/res/drawable/ic_recent_app_info.xml b/packages/SystemUI/res/drawable/ic_recent_app_info.xml
new file mode 100644
index 00000000000..1a1232dbd8c
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_recent_app_info.xml
@@ -0,0 +1,24 @@
+<!--
+    Copyright (C) 2016 The Android Open Source Project
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+         http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="24dp"
+        android:height="24dp"
+        android:viewportWidth="24"
+        android:viewportHeight="24">
+    <path
+        android:fillColor="#ffffff"
+        android:pathData="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
+</vector>
diff --git a/packages/SystemUI/res/drawable/ic_recent_favorite.xml b/packages/SystemUI/res/drawable/ic_recent_favorite.xml
new file mode 100644
index 00000000000..30d47d1fc80
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_recent_favorite.xml
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="23.98dp"
+    android:height="22.98dp"
+    android:viewportWidth="23.98"
+    android:viewportHeight="22.98">
+
+    <path
+        android:fillColor="#ffda00"
+        android:pathData="M4.57 22.95c0.94-2.89 1.89-5.79 2.83-8.68-2.47-1.76-4.93-3.51-7.4-5.27 3.03-0.03
+6.06-0.01 9.08-0.02 0.97-2.99 1.92-5.99 2.9-8.98 0.97 3 1.93 5.99 2.9
+8.98h9.1c-2.47 1.77-4.95 3.53-7.42 5.29 0.94 2.9 1.89 5.8 2.83
+8.71-2.47-1.79-4.93-3.6-7.41-5.38-2.47 1.77-4.95 3.63-7.41 5.35z" />
+</vector>
diff --git a/packages/SystemUI/res/drawable/ic_recent_keyguard.xml b/packages/SystemUI/res/drawable/ic_recent_keyguard.xml
new file mode 100644
index 00000000000..146ae404eb3
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_recent_keyguard.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="72dp"
+    android:height="72dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+
+    <path
+        android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="#b3b3b3"
+        android:pathData="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1 .9 2 2
+2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9
+2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z" />
+</vector>
diff --git a/packages/SystemUI/res/drawable/ic_shop.xml b/packages/SystemUI/res/drawable/ic_shop.xml
new file mode 100644
index 00000000000..423b0acd6fe
--- /dev/null
+++ b/packages/SystemUI/res/drawable/ic_shop.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+    android:width="24dp"
+    android:height="24dp"
+    android:viewportWidth="24"
+    android:viewportHeight="24">
+
+    <path
+        android:pathData="M0 0h24v24H0z" />
+    <path
+        android:fillColor="#ffffff"
+        android:pathData="M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11 .89 2 2 2h16c1.11 0
+2-.89 2-2V6h-6zm-6-2h4v2h-4V4zM9 18V9l7.5 4L9 18z" />
+</vector>
diff --git a/packages/SystemUI/res/layout/recent_base_card.xml b/packages/SystemUI/res/layout/recent_base_card.xml
new file mode 100644
index 00000000000..16dcd45e4c5
--- /dev/null
+++ b/packages/SystemUI/res/layout/recent_base_card.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<com.android.cards.view.CardView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:card="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/list_cardId"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content"
+    style="@style/list_card"
+    card:card_layout_resourceID="@layout/recent_base_card_layout"
+    />
diff --git a/packages/SystemUI/res/layout/recent_base_card_layout.xml b/packages/SystemUI/res/layout/recent_base_card_layout.xml
new file mode 100644
index 00000000000..e937021ce97
--- /dev/null
+++ b/packages/SystemUI/res/layout/recent_base_card_layout.xml
@@ -0,0 +1,119 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:card="http://schemas.android.com/apk/res-auto"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content">
+
+    <!-- Card visible layout -->
+    <FrameLayout
+        android:id="@+id/card_reveal_layout"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+    <LinearLayout
+        android:id="@+id/card_main_layout"
+        style="@style/card.main_layout"
+        android:orientation="horizontal"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent">
+
+        <com.android.cards.view.component.CardThumbnailView
+            style="@style/card_thumbnail_outer_layout"
+            android:id="@+id/card_thumbnail_layout"
+            card:card_thumbnail_layout_resourceID="@layout/recent_base_card_thumbnail"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content" />
+
+        <LinearLayout
+            android:orientation="vertical"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent">
+
+            <com.android.cards.view.component.CardHeaderView
+                style="@style/card.header_outer_layout"
+                android:id="@+id/card_header_layout"
+                android:layout_weight="1"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content" />
+
+        </LinearLayout>
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:visibility="gone"
+        android:orientation="horizontal"
+        android:id="@+id/card_options"
+        android:paddingBottom="4dp"
+        android:paddingTop="4dp"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:background="#ffff0000">
+
+        <ImageView
+            style="@style/SlimRecentsCardOptionsButton"
+            android:id="@+id/app_info"
+            android:layout_weight="1"
+            android:layout_width="52dp"
+            android:layout_height="match_parent"
+            android:src="@drawable/ic_recent_app_info" />
+
+        <ImageView
+            style="@style/SlimRecentsCardOptionsButton"
+            android:id="@+id/market"
+            android:layout_weight="1"
+            android:layout_width="52dp"
+            android:layout_height="match_parent"
+            android:src="@drawable/ic_shop" />
+
+        <ImageView
+            style="@style/SlimRecentsCardOptionsButton"
+            android:id="@+id/multiwindow"
+            android:layout_weight="1"
+            android:layout_width="52dp"
+            android:layout_height="match_parent"
+            android:src="@drawable/ic_multiwindow" />
+
+        <ImageView
+            style="@style/SlimRecentsCardOptionsButton"
+            android:id="@+id/close"
+            android:layout_weight="1"
+            android:layout_width="52dp"
+            android:layout_height="match_parent"
+            android:src="@drawable/ic_done" />
+
+    </LinearLayout>
+
+    </FrameLayout>
+
+    <FrameLayout
+        android:id="@+id/card_content_expand_layout"
+        style="@style/card.main_contentExpand_inside"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        />
+
+    <!--<com.android.cards.view.component.CardShadowView
+        style="@style/card.shadow_outer_layout"
+        android:id="@+id/card_shadow_layout"
+        android:layout_width="match_parent"
+    android:layout_height="wrap_content" />-->
+
+</LinearLayout>
diff --git a/packages/SystemUI/res/layout/recent_base_card_thumbnail.xml b/packages/SystemUI/res/layout/recent_base_card_thumbnail.xml
new file mode 100644
index 00000000000..bd101340a56
--- /dev/null
+++ b/packages/SystemUI/res/layout/recent_base_card_thumbnail.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/card_thumbnail"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content">
+
+    <com.android.systemui.slimrecent.RecentImageView
+        android:id="@+id/card_thumbnail_image"
+        style="@style/card.card_header_app_icon"/>
+
+    <com.android.systemui.slimrecent.RecentImageView
+        android:id="@+id/card_thumbnail_favorite"
+        android:src="@drawable/ic_recent_favorite"
+        android:layout_toEndOf="@id/card_thumbnail_image"
+        android:visibility="invisible"
+        style="@style/card.card_header_favorite_icon"/>
+
+</RelativeLayout>
diff --git a/packages/SystemUI/res/layout/recent_inner_card_expand.xml b/packages/SystemUI/res/layout/recent_inner_card_expand.xml
new file mode 100644
index 00000000000..7ba73240c5c
--- /dev/null
+++ b/packages/SystemUI/res/layout/recent_inner_card_expand.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:orientation="vertical"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:gravity="center">
+
+    <com.android.systemui.slimrecent.RecentImageView
+        android:id="@+id/thumbnail"
+        android:layout_width="@dimen/recent_thumbnail_width"
+        android:layout_height="@dimen/recent_thumbnail_height"
+        android:layout_marginBottom="@dimen/recent_thumbnail_bottom_padding"
+        />
+
+</LinearLayout>
diff --git a/packages/SystemUI/res/layout/slim_recent.xml b/packages/SystemUI/res/layout/slim_recent.xml
new file mode 100644
index 00000000000..13f011ddb5f
--- /dev/null
+++ b/packages/SystemUI/res/layout/slim_recent.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 SlimRoms Project
+               (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:card="http://schemas.android.com/apk/res-auto"
+    android:id="@+id/main"
+    android:paddingStart="@dimen/slim_recents_elevation"
+    android:elevation="@dimen/slim_recents_elevation"
+    android:clipToPadding="false"
+    android:layout_width="@dimen/recent_width"
+    android:layout_height="match_parent" >
+
+    <LinearLayout
+        android:id="@+id/recent_content"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:orientation="vertical"
+        android:gravity="center" >
+
+        <com.android.cards.recyclerview.view.CardRecyclerView
+            android:id="@+id/recent_list"
+            android:layout_width="match_parent"
+            android:layout_height="match_parent"
+            android:stackFromBottom="true"
+            android:scrollbars="none"
+            android:overScrollMode="never"
+            android:background="@android:color/transparent"
+            android:cacheColorHint="@android:color/transparent"
+            android:fitsSystemWindows="true"
+            android:clipToPadding="false"
+            android:clipChildren="false"
+            card:list_card_layout_resourceID="@layout/recent_base_card" />
+
+        <ImageView
+            android:id="@+id/empty_recent"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:visibility="gone"
+            android:src="@drawable/ic_empty_recent"
+            />
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:id="@+id/recent_warning_content"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:gravity="top|center_horizontal"
+        android:orientation="vertical"
+        android:visibility="gone"
+        android:background="#ffff0000" >
+
+        <ImageView
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="30dp"
+            android:src="@drawable/ic_menu_delete"
+            />
+
+    </LinearLayout>
+
+</RelativeLayout>
diff --git a/packages/SystemUI/res/layout/slim_recent_keyguard.xml b/packages/SystemUI/res/layout/slim_recent_keyguard.xml
new file mode 100644
index 00000000000..f675962ee69
--- /dev/null
+++ b/packages/SystemUI/res/layout/slim_recent_keyguard.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<RelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:id="@+id/main"
+    android:paddingStart="@dimen/slim_recents_elevation"
+    android:elevation="@dimen/slim_recents_elevation"
+    android:layout_width="@dimen/recent_width"
+    android:layout_height="match_parent">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:layout_centerVertical="true">
+
+        <ImageView
+            android:id="@+id/keyguard_recent_img"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_horizontal"
+            android:src="@drawable/ic_recent_keyguard" />
+
+        <TextView
+            android:id="@+id/keyguard_recent_text"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center"
+            android:gravity="center_horizontal"
+            android:layout_marginTop="@dimen/recent_keyguard_text_margin"
+            android:text="@string/slim_recent_keyguard" />
+
+    </LinearLayout>
+
+</RelativeLayout>
diff --git a/packages/SystemUI/res/values-land/cr_config.xml b/packages/SystemUI/res/values-land/cr_config.xml
new file mode 100644
index 00000000000..4f8349cf0f2
--- /dev/null
+++ b/packages/SystemUI/res/values-land/cr_config.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<!-- These resources are around just to allow their values to be customized
+     for different hardware and product builds. -->
+<resources>
+
+    <!-- Default value how much apps show the app screenshot on recents view entry -->
+    <integer name="expanded_items_default">1</integer>
+</resources>
diff --git a/packages/SystemUI/res/values-sw600dp-land/cr_config.xml b/packages/SystemUI/res/values-sw600dp-land/cr_config.xml
new file mode 100644
index 00000000000..0113bb45e7d
--- /dev/null
+++ b/packages/SystemUI/res/values-sw600dp-land/cr_config.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+     Copyright (C) 2017 crDroid Android Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<resources>
+
+    <!-- Default value how much apps show the app screenshot on recents view entry -->
+    <integer name="expanded_items_default">2</integer>
+</resources>
diff --git a/packages/SystemUI/res/values/custom_colors.xml b/packages/SystemUI/res/values/custom_colors.xml
index eb6fe6ae3f8..e00fcce9e2b 100644
--- a/packages/SystemUI/res/values/custom_colors.xml
+++ b/packages/SystemUI/res/values/custom_colors.xml
@@ -46,4 +46,9 @@
     <color name="batterymeter_frame_color_copy">#4DFFFFFF</color><!-- 30% white -->
     <color name="batterymeter_charge_color_copy">#FFFFFFFF</color>
     <color name="batterymeter_bolt_color_copy">#FFFFFFFF</color>
+
+    <!-- Slim recent -->
+    <color name="recent_background">#80000000</color>
+    <color name="recent_warning_background">#ff3367d6</color>
+
 </resources>
diff --git a/packages/SystemUI/res/values/custom_dimens.xml b/packages/SystemUI/res/values/custom_dimens.xml
index 2b5664dc406..64b73ef418c 100644
--- a/packages/SystemUI/res/values/custom_dimens.xml
+++ b/packages/SystemUI/res/values/custom_dimens.xml
@@ -44,4 +44,15 @@
     <dimen name="qs_panel_top_offset_normal">80dp</dimen>
     <dimen name="qs_panel_top_offset_header">110dp</dimen>
 
+    <!-- Slim recent -->
+    <dimen name="recent_width">230dp</dimen>
+    <dimen name="slim_recents_elevation">20dp</dimen>
+    <dimen name="recent_app_icon_size">48dp</dimen>
+    <dimen name="recent_favorite_icon_size">18dp</dimen>
+    <dimen name="recent_thumbnail_width">198dp</dimen>
+    <dimen name="recent_thumbnail_height">140dp</dimen>
+    <dimen name="recent_header_width">120dp</dimen>
+    <dimen name="recent_text_size">17dp</dimen>
+    <dimen name="recent_thumbnail_bottom_padding">3dp</dimen>
+    <dimen name="recent_keyguard_text_margin">8dp</dimen>
 </resources>
diff --git a/packages/SystemUI/res/values/custom_strings.xml b/packages/SystemUI/res/values/custom_strings.xml
index af922dea763..9ea2a5ab925 100644
--- a/packages/SystemUI/res/values/custom_strings.xml
+++ b/packages/SystemUI/res/values/custom_strings.xml
@@ -137,4 +137,8 @@
 
     <string name="pirate_label">Aaarrrggghhh</string>
     <string name="pirate_spec">pirate</string>
+
+    <!-- Slim recents -->
+    <string name="slim_recent_keyguard">Unlock your device to view recents</string>
+    <string name="recents_multiwin_warning">A multiwindow session is already active.\nJust tap an app if you want to dock it now.</string>
 </resources>
diff --git a/packages/SystemUI/res/values/custom_styles.xml b/packages/SystemUI/res/values/custom_styles.xml
index 4b80171e61f..7f0465b8324 100644
--- a/packages/SystemUI/res/values/custom_styles.xml
+++ b/packages/SystemUI/res/values/custom_styles.xml
@@ -62,4 +62,65 @@
     <style name="BatteryMeterViewDrawable.Portrait">
         <item name="blendMode">overlay</item>
     </style>
+
+    <!-- Slim recents -->
+    <style name="card.header_simple_title">
+        <item name="android:textSize">@dimen/recent_text_size</item>
+        <item name="android:fontFamily">sans-serif-condensed</item>
+        <item name="android:textColor">@color/card_text_color_header</item>
+        <item name="android:layout_width">@dimen/recent_header_width</item>
+        <item name="android:layout_height">@dimen/recent_app_icon_size</item>
+        <item name="android:gravity">start|center_vertical</item>
+        <item name="android:textAlignment">viewStart</item>
+        <item name="android:layout_marginStart">0dp</item>
+        <item name="android:layout_marginTop">4dp</item>
+        <item name="android:layout_marginEnd">0dp</item>
+        <item name="android:layout_marginBottom">6dp</item>
+        <item name="android:ellipsize">end</item>
+        <item name="android:singleLine">false</item>
+        <item name="android:lines">2</item>
+        <item name="android:maxLines">2</item>
+    </style>
+
+    <style name="card.card_header_app_icon">
+        <item name="android:layout_width">@dimen/recent_app_icon_size</item>
+        <item name="android:layout_height">@dimen/recent_app_icon_size</item>
+        <item name="android:layout_marginTop">5dp</item>
+        <item name="android:layout_marginStart">4dp</item>
+        <item name="android:layout_marginEnd">4dp</item>
+        <item name="android:layout_marginBottom">5dp</item>
+    </style>
+
+    <style name="card.card_header_favorite_icon">
+        <item name="android:layout_width">@dimen/recent_favorite_icon_size</item>
+        <item name="android:layout_height">@dimen/recent_favorite_icon_size</item>
+        <item name="android:layout_marginStart">-18dp</item>
+        <item name="android:layout_marginTop">1dp</item>
+    </style>
+
+    <style name="card.header_button_base">
+        <item name="android:layout_width">wrap_content</item>
+        <item name="android:layout_height">wrap_content</item>
+        <item name="android:layout_alignParentEnd">true</item>
+        <item name="android:paddingStart">@dimen/card_header_button_padding_start</item>
+        <item name="android:focusable">false</item>
+        <item name="android:focusableInTouchMode">false</item>
+        <item name="android:clickable">true</item>
+        <item name="android:layout_centerVertical">true</item>
+        <item name="android:layout_marginEnd">0dp</item>
+    </style>
+
+    <style name="RecentBaseStyle"  parent="@*android:style/Theme.Material.Light">
+        <item name="android:popupMenuStyle">@*android:style/Widget.Material.Light.ListPopupWindow</item>
+    </style>
+
+    <style name="card.main_contentExpand_inside">
+        <item name="android:background">@color/card_backgroundExpand</item>
+        <item name="android:padding">@dimen/card_expand_layout_padding</item>
+    </style>
+
+    <style name="SlimRecentsCardOptionsButton">
+        <item name="android:padding">2dp</item>
+    </style>
+
 </resources>
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/AppIconLoader.java b/packages/SystemUI/src/com/android/systemui/slimrecent/AppIconLoader.java
new file mode 100644
index 00000000000..71e3fe70a05
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/AppIconLoader.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2014-2016 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.Canvas;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.os.AsyncTask;
+import android.os.Process;
+
+import com.android.systemui.R;
+
+import java.lang.ref.WeakReference;
+
+/**
+ * This class handles async app icon load for the requested apps
+ * and put them when sucessfull into the LRU cache.
+ *
+ * Compared to the task screenshots this class is laid out due
+ * that the #link:CacheController can request an app icon as well
+ * eg if the app was updated and may changed the icon.
+ */
+public class AppIconLoader {
+
+    /**
+     * Singleton.
+     */
+    private static AppIconLoader sInstance;
+
+    private Context mContext;
+
+    /**
+     * Get the instance.
+     */
+    public static AppIconLoader getInstance(Context context) {
+        if (sInstance != null) {
+            return sInstance;
+        } else {
+            return sInstance = new AppIconLoader(context);
+        }
+    }
+
+    /**
+     * Constructor.
+     */
+    private AppIconLoader(Context context) {
+        mContext = context;
+    }
+
+    /**
+     * Load the app icon via async task.
+     *
+     * @params packageName
+     * @params imageView
+     */
+    protected void loadAppIcon(ResolveInfo info, String identifier,
+            RecentImageView imageView, float scaleFactor) {
+        final BitmapDownloaderTask task =
+                new BitmapDownloaderTask(imageView, mContext, scaleFactor, identifier);
+        task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, info);
+    }
+
+    /**
+     * Loads the actual app icon.
+     */
+    private static Drawable getAppIcon(ResolveInfo info, Context context, float scaleFactor) {
+        if (context == null) {
+            return null;
+        }
+        PackageManager pm = context.getPackageManager();
+        return getResizedBitmap(getFullResIcon(context, info, pm), context, scaleFactor);
+
+    }
+
+    private static Drawable getFullResDefaultActivityIcon(Context context) {
+        return getFullResIcon(context, Resources.getSystem(),
+                com.android.internal.R.mipmap.sym_def_app_icon);
+    }
+
+    private static Drawable getFullResIcon(Context context, Resources resources, int iconId) {
+        try {
+            return resources.getDrawableForDensity(iconId,
+                    context.getResources().getDisplayMetrics().densityDpi);
+        } catch (Resources.NotFoundException e) {
+            return getFullResDefaultActivityIcon(context);
+        }
+    }
+
+    private static Drawable getFullResIcon(Context context,
+            ResolveInfo info, PackageManager packageManager) {
+        Resources resources;
+        try {
+            resources = packageManager.getResourcesForApplication(
+                    info.activityInfo.applicationInfo);
+        } catch (PackageManager.NameNotFoundException e) {
+            resources = null;
+        }
+        if (resources != null) {
+            int iconId = info.activityInfo.getIconResource();
+            if (iconId != 0) {
+                return getFullResIcon(context, resources, iconId);
+            }
+        }
+        return getFullResDefaultActivityIcon(context);
+    }
+
+    /**
+     * Resize the app icon to the size we need to save space in our LRU cache.
+     * Normal we could assume that all app icons have the same default AOSP defined size.
+     * The reality shows that a lot apps do not care about and add just one big icon for
+     * all screen resolution.
+     */
+    private static Drawable getResizedBitmap(Drawable source, Context context, float scaleFactor) {
+        if (source == null) {
+            return null;
+        }
+
+        if (!(source instanceof BitmapDrawable)) {
+            return source;
+        }
+
+        final int iconSize = (int) (context.getResources()
+                .getDimensionPixelSize(R.dimen.recent_app_icon_size) * scaleFactor);
+
+        final Bitmap bitmap = ((BitmapDrawable) source).getBitmap();
+        final Bitmap scaledBitmap = Bitmap.createBitmap(iconSize, iconSize, Config.ARGB_8888);
+
+        final float ratioX = iconSize / (float) bitmap.getWidth();
+        final float ratioY = iconSize / (float) bitmap.getHeight();
+        final float middleX = iconSize / 2.0f;
+        final float middleY = iconSize / 2.0f;
+
+        final Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG);
+        paint.setAntiAlias(true);
+
+        final Matrix scaleMatrix = new Matrix();
+        scaleMatrix.setScale(ratioX, ratioY, middleX, middleY);
+
+        final Canvas canvas = new Canvas(scaledBitmap);
+        canvas.setMatrix(scaleMatrix);
+        canvas.drawBitmap(bitmap, middleX - bitmap.getWidth() / 2,
+                middleY - bitmap.getHeight() / 2, paint);
+
+        return new BitmapDrawable(context.getResources(), scaledBitmap);
+    }
+
+    /**
+     * AsyncTask loader for the app icon.
+     */
+    private static class BitmapDownloaderTask extends AsyncTask<ResolveInfo, Void, Drawable> {
+
+        private Drawable mAppIcon;
+
+        private final WeakReference<RecentImageView> rImageViewReference;
+        private final WeakReference<Context> rContext;
+
+        //private int mOrigPri;
+        private float mScaleFactor;
+
+        private String mLRUCacheKey;
+
+        public BitmapDownloaderTask(RecentImageView imageView,
+                Context context, float scaleFactor, String identifier) {
+            rImageViewReference = new WeakReference<RecentImageView>(imageView);
+            rContext = new WeakReference<Context>(context);
+            mScaleFactor = scaleFactor;
+            mLRUCacheKey = identifier;
+        }
+
+        @Override
+        protected Drawable doInBackground(ResolveInfo... params) {
+            // Save current thread priority and set it during the loading
+            // to background priority.
+            //mOrigPri = Process.getThreadPriority(Process.myTid());
+            Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
+            if (isCancelled() || rContext == null) {
+                return null;
+            }
+            // Load and return bitmap
+            return getAppIcon(params[0], rContext.get(), mScaleFactor);
+        }
+
+        @Override
+        protected void onPostExecute(Drawable bitmap) {
+            if (isCancelled()) {
+                bitmap = null;
+            }
+            // Restore original thread priority.
+            //Process.setThreadPriority(mOrigPri);
+
+            final Context context;
+            if (rContext != null) {
+                context = rContext.get();
+            } else {
+                context = null;
+            }
+            // Assign image to the view if the view was passed through.
+            // #link:loadAppIcon
+            if (rImageViewReference != null) {
+                final RecentImageView imageView = rImageViewReference.get();
+                if (imageView != null) {
+                    imageView.setImageDrawable(bitmap);
+                }
+                if (bitmap != null && context != null && bitmap instanceof BitmapDrawable) {
+                    // Put our bitmap intu LRU cache for later use.
+                    CacheController.getInstance(context)
+                            .addBitmapDrawableToMemoryCache(mLRUCacheKey, (BitmapDrawable)bitmap);
+                }
+            }
+        }
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/CacheController.java b/packages/SystemUI/src/com/android/systemui/slimrecent/CacheController.java
new file mode 100644
index 00000000000..bb0b6ea2634
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/CacheController.java
@@ -0,0 +1,326 @@
+/*
+ * Copyright (C) 2014-2017 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.app.ActivityManager;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.BroadcastReceiver;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.net.Uri;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.util.LruCache;
+
+import com.android.systemui.R;
+
+import java.util.ArrayList;
+
+/**
+ * This class is our LRU cache controller. It holds
+ * the app icons and the task screenshots.
+ *
+ * BroadcastReceiver takes care of the situation if the user updated
+ * or removed and installed again the app and the icon may have changed.
+ */
+public class CacheController {
+
+    private final static String TAG = "RecentCacheController";
+
+    /**
+     * Singleton.
+     */
+    private static CacheController sInstance;
+
+    /**
+     * Memory Cache.
+     */
+    protected LruCache<String, Bitmap> mMemoryCache;
+
+    private Context mContext;
+
+    private static String sKeyExcludeRecycle;
+    private static boolean sRecentScreenShowing;
+
+    // Array list of all current keys.
+    private final ArrayList<String> mKeys = new ArrayList<String>();
+
+    /**
+     * Get the instance.
+     */
+    public static CacheController getInstance(Context context) {
+        if (sInstance != null) {
+            return sInstance;
+        } else {
+            return sInstance = new CacheController(context);
+        }
+    }
+
+    /**
+     * Listen for package change or added broadcast.
+     */
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (Intent.ACTION_PACKAGE_CHANGED.equals(action)
+                    || Intent.ACTION_PACKAGE_ADDED.equals(action)
+                    || Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
+                // Get the package name from the intent.
+                Uri uri = intent.getData();
+                final String packageName = uri != null ? uri.getSchemeSpecificPart() : null;
+                if (packageName == null) {
+                    return;
+                }
+
+                // Check if icons from the searched package are present.
+                // If yes remove them.
+                final ArrayList<String> keysToRemove = new ArrayList<String>();
+                for (String key : mKeys) {
+                    if (key.toLowerCase().contains(packageName.toLowerCase())) {
+                        keysToRemove.add(key);
+                    }
+                }
+                for (String key : keysToRemove) {
+                    Log.d(TAG, "application icon removed for uri= " + key);
+                    setKeyExcludeRecycle(key);
+                    removeBitmapFromMemCache(key);
+                }
+                if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {
+                    mayBeRemoveFavoriteEntry(packageName);
+                }
+            }
+        }
+    };
+
+    /**
+     * Remove favorite if current app was uninstalled.
+     */
+    private void mayBeRemoveFavoriteEntry(String packageName) {
+        ContentResolver resolver = mContext.getContentResolver();
+        final String favorites = Settings.System.getStringForUser(
+                    resolver, Settings.System.RECENT_PANEL_FAVORITES,
+                    UserHandle.USER_CURRENT);
+        String entryToSave = "";
+
+        if (favorites == null || favorites != null && favorites.isEmpty()) {
+            return;
+        }
+        for (String favorite : favorites.split("\\|")) {
+            if (favorite.toLowerCase().contains(packageName.toLowerCase())) {
+                continue;
+            }
+            entryToSave += favorite + "|";
+        }
+        if (!entryToSave.isEmpty()) {
+            entryToSave = entryToSave.substring(0, entryToSave.length() - 1);
+        }
+
+        Settings.System.putStringForUser(
+                resolver, Settings.System.RECENT_PANEL_FAVORITES,
+                entryToSave,
+                UserHandle.USER_CURRENT);
+    }
+
+    /**
+     * Constructor.
+     * Defines the LRU cache size and setup the broadcast receiver.
+     */
+    private CacheController(Context context) {
+        mContext = context;
+
+        final Resources res = context.getResources();
+
+        int maxNumTasksToLoad = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.RECENTS_MAX_APPS, 15,
+                UserHandle.USER_CURRENT);
+
+        // Gets the dimensions of the device's screen
+        DisplayMetrics dm = res.getDisplayMetrics();
+        final int screenWidth = dm.widthPixels;
+        final int screenHeight = dm.heightPixels;
+
+        // We have ARGB_8888 pixel format, 4 bytes per pixel
+        final int size = screenWidth * screenHeight * 4;
+
+        // Calculate how much thumbnails we can put per screen page
+        final int thumbnailWidth = res.getDimensionPixelSize(R.dimen.recent_thumbnail_width);
+        final int thumbnailHeight = res.getDimensionPixelSize(R.dimen.recent_thumbnail_height);
+        final float thumbnailsPerPage =
+                (screenWidth / thumbnailWidth) * (screenHeight / thumbnailHeight);
+
+        // Needed screen pages for max thumbnails we can get.
+        float neededPages = maxNumTasksToLoad / thumbnailsPerPage;
+
+        // Calculate how much app icons we can put per screen page
+        final int iconSize = res.getDimensionPixelSize(R.dimen.recent_app_icon_size);
+        final float iconsPerPage = (screenWidth / iconSize) * (screenHeight / iconSize);
+
+        // Needed screen pages for max thumbnails and max app icons we can get.
+        neededPages += maxNumTasksToLoad / iconsPerPage;
+
+        // Calculate final cache size, stored in kilobytes.
+        int cacheSize = (int) (size * neededPages / 1024);
+
+        // Get max available VM memory, exceeding this amount will throw an
+        // OutOfMemory exception. Stored in kilobytes as LruCache takes an
+        // int in its constructor.
+        final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);
+
+        // Do not allow more then 1/8 from max available memory.
+        if (cacheSize > maxMemory / 8) {
+            cacheSize = maxMemory / 8;
+        }
+
+        if (mMemoryCache == null) {
+            mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {
+                @Override
+                protected int sizeOf(String key, Bitmap bitmap) {
+                    return bitmap.getByteCount() / 1024;
+                }
+
+                @Override
+                protected void entryRemoved(boolean evicted, String key,
+                        Bitmap oldBitmap, Bitmap newBitmap) {
+                    /**
+                     * For normal LRU cache designs this is not a valid approach.
+                     * Well in our case it is another case. The LRU cache control
+                     * was designed in this way that we can be 100% sure if a put(K, V)
+                     * or a remove(V) was called that we do not have any reference to
+                     * this bitmap anymore. So it can be savely recycled.
+                     * Cases are:
+                     * 1. New bitmap was put into the LRU cache. Shortly before the loaders
+                     *    assign the new bitmap to the imageview. So old one has no reference.
+                     * 2. Task entry was removed which removes as well any reference to the bitmap.
+                     *    So we are save here as well.
+                     * 3. The CacheController broadcastreceiver removes the bitmap from
+                     *    the LRU cache. When this happens we recycle only if the recent screen
+                     *    is not shown due that we may have a valid reference. This scenario
+                     *    is realy realy rare. So we are save and can recycle in most of the cases
+                     *    if an app was updated by the user. So we do not need to worry to produce
+                     *    a memory leak here at all.
+                     * 4. The case that the entry was evicted. Here we do not recycle the old
+                     *    image. Well this case should never happen due that our LRU cache is
+                     *    exactly meassured to keep all tasks in memory.
+                     *    Just in case we still check for it.
+                     */
+                    if (!evicted) {
+                        if (key != null && key.equals(getKeyExcludeRecycle())) {
+                            setKeyExcludeRecycle(null);
+                            if (isRecentScreenShowing()) {
+                                return;
+                            }
+                        }
+                        oldBitmap.recycle();
+                        oldBitmap = null;
+                    }
+                }
+            };
+        }
+
+        // Receive broadcasts
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_PACKAGE_CHANGED);
+        filter.addAction(Intent.ACTION_PACKAGE_ADDED);
+        filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
+        filter.addDataScheme("package");
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+    }
+
+    /**
+     * Add the bitmap to the LRU cache.
+     */
+    protected void addBitmapToMemoryCache(String key, Bitmap bitmap) {
+        if (key != null && bitmap != null) {
+            if (key.startsWith(RecentPanelView.TASK_PACKAGE_IDENTIFIER)) {
+                mKeys.add(key);
+            }
+            mMemoryCache.put(key, bitmap);
+        }
+    }
+
+    /**
+     * Add the bitmap from Drawable to the LRU cache.
+     */
+    protected void addBitmapDrawableToMemoryCache(String key, BitmapDrawable bitmap) {
+        if (key != null && bitmap != null) {
+            if (key.startsWith(RecentPanelView.TASK_PACKAGE_IDENTIFIER)) {
+                mKeys.add(key);
+            }
+            mMemoryCache.put(key, bitmap.getBitmap());
+        }
+    }
+
+    /**
+     * Get the bitmap from the LRU cache.
+     */
+    protected Bitmap getBitmapFromMemCache(String key) {
+        if (key == null) {
+            return null;
+        }
+        return mMemoryCache.get(key);
+    }
+
+    /**
+     * Remove a bitmap from the LRU cache.
+     */
+    protected Bitmap removeBitmapFromMemCache(String key) {
+        if (key == null) {
+            return null;
+        }
+        if (key.startsWith(RecentPanelView.TASK_PACKAGE_IDENTIFIER)) {
+            mKeys.remove(key);
+        }
+        return mMemoryCache.remove(key);
+    }
+
+    /**
+     * Set key which should be excluded from recycle if recent panel is showing.
+     * Call by BroadCastReceiver.
+     */
+    protected void setKeyExcludeRecycle(String key) {
+        sKeyExcludeRecycle = key;
+    }
+
+    /**
+     * Get key which should be excluded from recycle.
+     */
+    private static String getKeyExcludeRecycle() {
+        return sKeyExcludeRecycle;
+    }
+
+    /**
+     * Set wether recent screen is showing. Call from RecentController.
+     */
+    protected void setRecentScreenShowing(boolean showing) {
+        sRecentScreenShowing = showing;
+    }
+
+    /**
+     * Wether recent screen is showing.
+     */
+    private static boolean isRecentScreenShowing() {
+        return sRecentScreenShowing;
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/ColorDrawableWithDimensions.java b/packages/SystemUI/src/com/android/systemui/slimrecent/ColorDrawableWithDimensions.java
new file mode 100644
index 00000000000..e871f5ddf64
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/ColorDrawableWithDimensions.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ * Copyright (C) 2014-2016 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.graphics.drawable.ColorDrawable;
+
+public class ColorDrawableWithDimensions extends ColorDrawable {
+    private int mWidth;
+    private int mHeight;
+
+    public ColorDrawableWithDimensions(int color, int width, int height) {
+        super(color);
+        mWidth = width;
+        mHeight = height;
+    }
+
+    @Override
+    public int getIntrinsicWidth() {
+        return mWidth;
+    }
+
+    @Override
+    public int getIntrinsicHeight() {
+        return mHeight;
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/ColorUtils.java b/packages/SystemUI/src/com/android/systemui/slimrecent/ColorUtils.java
new file mode 100644
index 00000000000..c3089c1a608
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/ColorUtils.java
@@ -0,0 +1,55 @@
+/*
+* Copyright (C) 2016-2017 SlimRoms Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package com.android.systemui.slimrecent;
+
+import android.graphics.Color;
+
+public class ColorUtils {
+
+    public static boolean isDarkColor(int color) {
+        double darkness = 1-(0.299 * Color.red(color)
+                + 0.587 * Color.green(color) + 0.114 * Color.blue(color)) / 255;
+
+        return darkness > 0.5;
+    }
+
+    public static int darkenColor(int color) {
+        float factor = 0.8f;
+        int a = Color.alpha(color);
+        int r = Color.red(color);
+        int g = Color.green(color);
+        int b = Color.blue(color);
+
+        return Color.argb(a,
+                Math.max((int) (r * factor), 0 ),
+                Math.max((int) (g * factor), 0 ),
+                Math.max((int) (b * factor), 0 ));
+    }
+
+    public static int lightenColor(int color) {
+        float factor = 1.2f;
+        int a = Color.alpha(color);
+        int r = Color.red(color);
+        int g = Color.green(color);
+        int b = Color.blue(color);
+
+        return Color.argb(a,
+                Math.max((int) (r * factor), 0 ),
+                Math.max((int) (g * factor), 0 ),
+                Math.max((int) (b * factor), 0 ));
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentAppIcon.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentAppIcon.java
new file mode 100644
index 00000000000..968cfae678a
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentAppIcon.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2014-2016 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.content.Context;
+import android.content.pm.ResolveInfo;
+import android.graphics.Bitmap;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.android.cards.internal.CardThumbnail;
+import com.android.systemui.R;
+
+/**
+ * This class handles the view of our app icon.
+ */
+public class RecentAppIcon extends CardThumbnail {
+
+    private Context mContext;
+
+    private int mIconSize;
+    private float mScaleFactor;
+    private boolean mScaleFactorChanged;
+    private boolean mIsFavorite;
+    private String mIdentifier;
+    private ResolveInfo mInfo;
+
+    public RecentAppIcon(Context context, ResolveInfo info, String identifier,
+            float scaleFactor, boolean isFavorite) {
+        super(context);
+        mContext = context;
+        mInfo = info;
+        mIdentifier = identifier;
+        mScaleFactor = scaleFactor;
+        mIsFavorite = isFavorite;
+
+        mIconSize = (int) context.getResources()
+                .getDimensionPixelSize(R.dimen.recent_app_icon_size);
+    }
+
+    // Update icon.
+    public void updateIcon(ResolveInfo info, String identifier,
+            float scaleFactor, boolean isFavorite) {
+        mInfo = info;
+        mIdentifier = identifier;
+        mIsFavorite = isFavorite;
+        if (scaleFactor != mScaleFactor) {
+            mScaleFactorChanged = true;
+            mScaleFactor = scaleFactor;
+        }
+    }
+
+    /**
+     * Assign the icon to the view. If it is cached fetch it from the cache.
+     * If not call the app icon loader.
+     */
+    @Override
+    public void setupInnerViewElements(ViewGroup parent, View view) {
+        if (view == null || mIdentifier == null || mInfo == null) {
+            return;
+        }
+
+        // We use here a view holder to reduce expensive findViewById calls
+        // when getView is called on the arrayadapter which calls setupInnerViewElements.
+        // Simply just check if the given view was already tagged. If yes we know it has
+        // the appIconView we want to have. If not we search it, give it to the viewholder
+        // and tag the view for the next call to reuse the holded information later.
+        ViewHolder holder;
+        holder = (ViewHolder) view.getTag();
+
+        if (holder == null) {
+            holder = new ViewHolder();
+            holder.appIconView = (RecentImageView) view.findViewById(R.id.card_thumbnail_image);
+            holder.favIconView = (RecentImageView) parent.findViewById(R.id.card_thumbnail_favorite);
+            // Take scale factor into account if it is different then default or it has changed.
+            if (mScaleFactor != RecentController.DEFAULT_SCALE_FACTOR || mScaleFactorChanged) {
+                mScaleFactorChanged = false;
+                final ViewGroup.LayoutParams layoutParams = holder.appIconView.getLayoutParams();
+                layoutParams.width = layoutParams.height = (int) (mIconSize * mScaleFactor);
+                holder.appIconView.setLayoutParams(layoutParams);
+            }
+            view.setTag(holder);
+        }
+
+        final Bitmap appIcon =
+                CacheController.getInstance(mContext).getBitmapFromMemCache(mIdentifier);
+        if (appIcon == null || mScaleFactorChanged) {
+            mScaleFactorChanged = false;
+            AppIconLoader.getInstance(mContext).loadAppIcon(
+                    mInfo, mIdentifier, holder.appIconView, mScaleFactor);
+        } else {
+            holder.appIconView.setImageBitmap(appIcon);
+        }
+
+        holder.favIconView.setVisibility(mIsFavorite ? View.VISIBLE : View.INVISIBLE);
+
+    }
+
+    static class ViewHolder {
+        RecentImageView appIconView;
+        RecentImageView favIconView;
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentCard.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentCard.java
new file mode 100644
index 00000000000..9c82734bfd8
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentCard.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2014-2017 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import static com.android.systemui.slimrecent.RecentPanelView.DEBUG;
+import static com.android.systemui.slimrecent.RecentPanelView.PLAYSTORE_REFERENCE;
+import static com.android.systemui.slimrecent.RecentPanelView.AMAZON_REFERENCE;
+import static com.android.systemui.slimrecent.RecentPanelView.PLAYSTORE_APP_URI_QUERY;
+import static com.android.systemui.slimrecent.RecentPanelView.AMAZON_APP_URI_QUERY;
+
+import android.app.ActivityManager;
+import android.app.ActivityManagerNative;
+import android.app.ActivityOptions;
+import android.app.TaskStackBuilder;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.drawable.ColorDrawable;
+import android.net.Uri;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.widget.Toast;
+
+import com.android.cards.internal.Card;
+import com.android.cards.internal.CardHeader;
+import com.android.cards.view.CardView;
+
+import com.android.systemui.R;
+import com.android.systemui.SystemUIApplication;
+import com.android.systemui.stackdivider.WindowManagerProxy;
+import com.android.systemui.statusbar.phone.PhoneStatusBar;
+
+/**
+ * This class handles our base card view.
+ */
+public class RecentCard extends Card {
+
+    private static final boolean DEBUG = false;
+
+    private static final String PLAYSTORE_REFERENCE = "com.android.vending";
+    private static final String AMAZON_REFERENCE    = "com.amazon.venezia";
+
+    private static final String PLAYSTORE_APP_URI_QUERY = "market://details?id=";
+    private static final String AMAZON_APP_URI_QUERY    = "amzn://apps/android?p=";
+
+    private RecentHeader mHeader;
+    private RecentAppIcon mRecentIcon;
+    private RecentExpandedCard mExpandedCard;
+
+    private int mPersistentTaskId;
+
+    private int mCardColor;
+
+    private RecentController mSlimRecents;
+
+    private TaskDescription mTaskDescription;
+
+    private int defaultCardBg = mContext.getResources().getColor(
+                R.color.recents_task_bar_default_background_color);
+
+    public RecentCard(Context context, TaskDescription td, float scaleFactor) {
+        this(context, R.layout.inner_base_main, td, scaleFactor);
+    }
+
+    public RecentCard(Context context, int innerLayout, TaskDescription td, float scaleFactor) {
+        super(context, innerLayout);
+
+        constructBaseCard(context, td, scaleFactor);
+    }
+
+    // Construct our card.
+    private void constructBaseCard(Context context,
+            final TaskDescription td, float scaleFactor) {
+
+        mTaskDescription = td;
+
+        // Construct card header view.
+        mHeader = new RecentHeader(mContext, td, scaleFactor);
+
+        // Construct app icon view.
+        mRecentIcon = new RecentAppIcon(
+                context, td.resolveInfo, td.identifier, scaleFactor, td.getIsFavorite());
+        mRecentIcon.setExternalUsage(true);
+
+        // Construct expanded area view.
+        mExpandedCard = new RecentExpandedCard(context, td, scaleFactor);
+        initExpandedState(td);
+
+        mCardColor = getDefaultCardColorBg(td);
+
+        this.setBackgroundResource(new ColorDrawable(mCardColor));
+
+        // Finally add header, icon and expanded area to our card.
+        addCardHeader(mHeader);
+        addCardThumbnail(mRecentIcon);
+        addCardExpand(mExpandedCard);
+
+        mPersistentTaskId = td.persistentTaskId;
+    }
+
+    /** Returns the activity's primary color. */
+    public int getDefaultCardColorBg(TaskDescription td) {
+        if (td != null && td.cardColor != 0) {
+            return td.cardColor;
+        }
+        return defaultCardBg;
+    }
+
+    // Update content of our card.
+    public void updateCardContent(final TaskDescription td, float scaleFactor) {
+        mTaskDescription = td;
+
+        if (mHeader != null) {
+            // Set or update the header title.
+            mHeader.updateHeader(td, scaleFactor);
+        }
+        if (mRecentIcon != null) {
+            mRecentIcon.updateIcon(
+                    td.resolveInfo, td.identifier, scaleFactor, td.getIsFavorite());
+        }
+        if (mExpandedCard != null) {
+            // Set expanded state.
+            initExpandedState(td);
+            // Update app screenshot.
+            mExpandedCard.updateExpandedContent(td, scaleFactor);
+        }
+        mPersistentTaskId = td.persistentTaskId;
+
+        mCardColor = getDefaultCardColorBg(td);
+
+        this.setBackgroundResource(new ColorDrawable(getDefaultCardColorBg(td)));
+    }
+
+    // Set initial expanded state of our card.
+    private void initExpandedState(TaskDescription td) {
+        // Read flags and set accordingly initial expanded state.
+        final boolean isTopTask =
+                (td.getExpandedState() & RecentPanelView.EXPANDED_STATE_TOPTASK) != 0;
+
+        final boolean isSystemExpanded =
+                (td.getExpandedState() & RecentPanelView.EXPANDED_STATE_BY_SYSTEM) != 0;
+
+        final boolean isUserExpanded =
+                (td.getExpandedState() & RecentPanelView.EXPANDED_STATE_EXPANDED) != 0;
+
+        final boolean isUserCollapsed =
+                (td.getExpandedState() & RecentPanelView.EXPANDED_STATE_COLLAPSED) != 0;
+
+        final boolean isExpanded =
+                ((isSystemExpanded && !isUserCollapsed) || isUserExpanded) && !isTopTask;
+
+        if (mHeader != null) {
+            // Set visible the expand/collapse button.
+            mHeader.setButtonExpandVisible(!isTopTask);
+            mHeader.setOtherButtonDrawable(R.drawable.recents_lock_to_app_pin);
+            mHeader.setOtherButtonClickListener(new CardHeader.OnClickCardHeaderOtherButtonListener() {
+                @Override
+                public void onButtonItemClick(Card card, View view) {
+                    Context appContext = mContext.getApplicationContext();
+                    if (appContext == null) appContext = mContext;
+                    if (appContext instanceof SystemUIApplication) {
+                        SystemUIApplication app = (SystemUIApplication) appContext;
+                        PhoneStatusBar statusBar = app.getComponent(PhoneStatusBar.class);
+                        if (statusBar != null) {
+                            statusBar.showScreenPinningRequest(mPersistentTaskId, false);
+                        }
+                    }
+                }
+            });
+            mHeader.setOtherButtonVisible(isTopTask && screenPinningEnabled());
+        }
+
+        setExpanded(isExpanded);
+    }
+
+    private boolean screenPinningEnabled() {
+        return Settings.System.getInt(getContext().getContentResolver(),
+                Settings.System.LOCK_TO_APP_ENABLED, 0) != 0;
+    }
+
+    @Override
+    public void setupInnerViewElements(ViewGroup parent, View view) {
+        // Nothing to do here.
+        return;
+    }
+
+    public TaskDescription getTaskDescription() {
+        return mTaskDescription;
+    }
+
+    public int getPersistentTaskId() {
+        return mPersistentTaskId;
+    }
+
+    @Override
+    public void setupOptionsItems(final CardView cv) {
+        View options = cv.findViewById(R.id.card_options);
+        // set custom background
+        if (ColorUtils.isDarkColor(mCardColor)) {
+            options.setBackgroundColor(ColorUtils.lightenColor(mCardColor));
+        } else {
+            options.setBackgroundColor(ColorUtils.darkenColor(mCardColor));
+        }
+
+        if (!checkAppInstaller(mTaskDescription.packageName, AMAZON_REFERENCE)
+                && !checkAppInstaller(mTaskDescription.packageName, PLAYSTORE_REFERENCE)) {
+            options.findViewById(R.id.market).setVisibility(View.GONE);
+        }
+
+        View.OnClickListener listener = new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                int id = v.getId();
+                Intent intent = null;
+                if (id == R.id.app_info) {
+                    intent = getAppInfoIntent();
+                } else if (id == R.id.market) {
+                    intent = getStoreIntent();
+                }
+                if (id == R.id.multiwindow) {
+                    //if a multiwin session is already active, ask the user to close it
+                    int dockSide = WindowManagerProxy.getInstance().getDockSide();
+                    if (dockSide != WindowManager.DOCKED_INVALID) {
+                        Toast mWarningToast = Toast.makeText(mContext, R.string.recents_multiwin_warning, Toast.LENGTH_LONG);
+                        mWarningToast.show();
+                        return;
+                    }
+
+                    ActivityOptions options = ActivityOptions.makeBasic();
+                    options.setDockCreateMode(0);
+                    options.setLaunchStackId(ActivityManager.StackId.DOCKED_STACK_ID);
+                    mSlimRecents = new RecentController(mContext, getContext().getResources()
+                            .getConfiguration().getLayoutDirection());
+                    try {
+                        ActivityManagerNative.getDefault()
+                                .startActivityFromRecents(mPersistentTaskId, options.toBundle());
+                        mSlimRecents.openLastApptoBottom();
+                        hideCurrentOptions();
+                    } catch (RemoteException e) {}
+                    return; 
+                }
+                if (intent != null) {
+                    RecentController.sendCloseSystemWindows("close_recents");
+                    intent.setComponent(intent.resolveActivity(mContext.getPackageManager()));
+                    TaskStackBuilder.create(mContext)
+                            .addNextIntentWithParentStack(intent).startActivities(
+                                    RecentPanelView.getAnimation(getContext(), getRecentGravity()));
+                    return;
+                }
+
+                int[] location = new int[2];
+                v.getLocationOnScreen(location);
+                cv.hideOptions(location[0], location[1]);
+            }
+        };
+
+        options.findViewById(R.id.app_info).setOnClickListener(listener);
+        options.findViewById(R.id.market).setOnClickListener(listener);
+        options.findViewById(R.id.close).setOnClickListener(listener);
+        options.findViewById(R.id.multiwindow).setOnClickListener(listener);
+    }
+
+    public void hideCurrentOptions() {
+        getCardView().hideOptions(-1, -1);
+    }
+
+    private Intent getAppInfoIntent() {
+        return new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
+                    Uri.fromParts("package", mTaskDescription.packageName, null));
+    }
+
+    private Intent getStoreIntent() {
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        String reference;
+        if (checkAppInstaller(mTaskDescription.packageName, AMAZON_REFERENCE)) {
+            reference = AMAZON_REFERENCE;
+            intent.setData(Uri.parse(AMAZON_APP_URI_QUERY + mTaskDescription.packageName));
+        } else {
+            reference = PLAYSTORE_REFERENCE;
+            intent.setData(Uri.parse(PLAYSTORE_APP_URI_QUERY + mTaskDescription.packageName));
+        }
+        // Exclude from recents if the store is not in our task list.
+        intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+        return intent;
+    }
+
+    /**
+     * Check if the requested app was installed by the reference store.
+     */
+    private boolean checkAppInstaller(String packageName, String reference) {
+        if (packageName == null) {
+            return false;
+        }
+        PackageManager pm = mContext.getPackageManager();
+        if (!isReferenceInstalled(reference, pm)) {
+            return false;
+        }
+
+        String installer = pm.getInstallerPackageName(packageName);
+        if (DEBUG) Log.d(TAG, "Package was installed by: " + installer);
+        if (reference.equals(installer)) {
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Check is store reference is installed.
+     */
+    private boolean isReferenceInstalled(String packagename, PackageManager pm) {
+        try {
+            pm.getPackageInfo(packagename, PackageManager.GET_ACTIVITIES);
+            return true;
+        } catch (NameNotFoundException e) {
+            if (DEBUG) Log.e(TAG, "Store is not installed: " + packagename, e);
+            return false;
+        }
+    }
+
+    private int getRecentGravity() {
+        // Get user gravity.
+        int userGravity = Settings.System.getIntForUser(getContext().getContentResolver(),
+                Settings.System.RECENT_PANEL_GRAVITY, Gravity.RIGHT,
+                UserHandle.USER_CURRENT);
+        if (getContext().getResources()
+                .getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
+            if (userGravity == Gravity.LEFT) {
+                return Gravity.RIGHT;
+            } else {
+                return Gravity.LEFT;
+            }
+        } else {
+            return userGravity;
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentController.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentController.java
new file mode 100644
index 00000000000..00be7ae0d65
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentController.java
@@ -0,0 +1,925 @@
+/*
+ * Copyright (C) 2014-2017 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.app.ActivityManager;
+import android.app.ActivityManagerNative;
+import android.app.ActivityOptions;
+import android.app.KeyguardManager;
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.animation.ValueAnimator;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.database.ContentObserver;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.VectorDrawable;
+import android.graphics.PixelFormat;
+import android.graphics.Point;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.util.Log;
+import android.view.Display;
+import android.view.Gravity;
+import android.view.IWindowManager;
+import android.view.KeyEvent;
+import android.view.MotionEvent;
+import android.view.ScaleGestureDetector;
+import android.view.ScaleGestureDetector.SimpleOnScaleGestureListener;
+import android.view.WindowManager;
+import android.view.WindowManagerGlobal;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.TextView;
+
+import com.android.cards.recyclerview.view.CardRecyclerView;
+
+import com.android.systemui.R;
+import com.android.systemui.RecentsComponent;
+import com.android.systemui.recents.misc.Utilities;
+import com.android.systemui.recents.misc.SystemServicesProxy;
+import com.android.systemui.statusbar.BaseStatusBar;
+
+import java.util.List;
+
+/**
+ * Our main recents controller.
+ * Takes care of the toggle, preload, cancelpreload and close requests
+ * and passes the requested actions trough to our views and the panel
+ * view controller #link:RecentPanelView.
+ *
+ * As well the in out animation, constructing the main window container
+ * and the remove all tasks animation/detection (#link:RecentListOnScaleGestureListener)
+ * are handled here.
+ */
+public class RecentController implements RecentPanelView.OnExitListener,
+        RecentPanelView.OnTasksLoadedListener {
+
+    private static final String TAG = "SlimRecentsController";
+    private static final boolean DEBUG = false;
+
+    // Animation control values.
+    private static final int ANIMATION_STATE_NONE = 0;
+    private static final int ANIMATION_STATE_OUT  = 1;
+
+    // Animation state.
+    private int mAnimationState = ANIMATION_STATE_NONE;
+
+    public static float DEFAULT_SCALE_FACTOR = 1.0f;
+
+    private Context mContext;
+    private WindowManager mWindowManager;
+    private IWindowManager mWindowManagerService;
+
+    private boolean mIsShowing;
+    private boolean mIsToggled;
+    private boolean mIsPreloaded;
+
+    protected long mLastToggleTime;
+
+    // The different views we need.
+    private ViewGroup mParentView;
+    private ViewGroup mRecentContainer;
+    private View mKeyguardView;
+    private LinearLayout mRecentContent;
+    private LinearLayout mRecentWarningContent;
+    private ImageView mEmptyRecentView;
+    private ImageView mKeyguardImage;
+    private TextView mKeyguardText;
+
+    private int mLayoutDirection;
+    private int mMainGravity;
+    private int mUserGravity;
+    private int mPanelColor;
+
+    private float mScaleFactor = DEFAULT_SCALE_FACTOR;
+
+    // Main panel view.
+    private RecentPanelView mRecentPanelView;
+
+    private Handler mHandler = new Handler();
+
+    private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
+        public void onReceive(Context context, Intent intent) {
+            if (DEBUG) Log.v(TAG, "onReceive: " + intent);
+            final String action = intent.getAction();
+            // Screen goes off or system dialogs should close.
+            // Get rid of our recents screen
+            if (Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action)) {
+                String reason = intent.getStringExtra("reason");
+                if (reason != null &&
+                        !reason.equals(BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS)) {
+                    hideRecents(false);
+                }
+                if (DEBUG) Log.d(TAG, "braodcast system dialog");
+            } else if (Intent.ACTION_SCREEN_OFF.equals(action)){
+                hideRecents(true);
+                if (DEBUG) Log.d(TAG, "broadcast screen off");
+            }
+        }
+    };
+
+    public RecentController(Context context, int layoutDirection) {
+        mContext = context;
+        mLayoutDirection = layoutDirection;
+
+        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+        mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
+
+        /**
+         * Add intent actions to listen on it.
+         * Screen off to get rid of recents,
+         * same if close system dialogs is requested.
+         */
+        IntentFilter filter = new IntentFilter();
+        filter.addAction(Intent.ACTION_SCREEN_OFF);
+        filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
+        mContext.registerReceiver(mBroadcastReceiver, filter);
+
+        mParentView = new FrameLayout(mContext);
+
+        // Inflate our recents layout
+        mRecentContainer =
+                (RelativeLayout) View.inflate(context, R.layout.slim_recent, null);
+
+        // Get contents for rebuilding and gesture detector.
+        mRecentContent =
+                (LinearLayout) mRecentContainer.findViewById(R.id.recent_content);
+
+        mRecentWarningContent =
+                (LinearLayout) mRecentContainer.findViewById(R.id.recent_warning_content);
+
+        final CardRecyclerView cardRecyclerView =
+                (CardRecyclerView) mRecentContainer.findViewById(R.id.recent_list);
+
+        cardRecyclerView.setHasFixedSize(true);
+        CacheMoreCardsLayoutManager llm = new CacheMoreCardsLayoutManager(context, mWindowManager);
+        llm.setReverseLayout(true);
+        cardRecyclerView.setLayoutManager(llm);
+
+        mEmptyRecentView =
+                (ImageView) mRecentContainer.findViewById(R.id.empty_recent);
+
+        mKeyguardView = View.inflate(context, R.layout.slim_recent_keyguard, null);
+
+        mKeyguardImage =
+                (ImageView) mKeyguardView.findViewById(R.id.keyguard_recent_img);
+
+        mKeyguardText = (TextView) mKeyguardView.findViewById(R.id.keyguard_recent_text);
+
+        // Prepare gesture detector.
+        final ScaleGestureDetector recentListGestureDetector =
+                new ScaleGestureDetector(mContext,
+                        new RecentListOnScaleGestureListener(
+                                mRecentWarningContent, cardRecyclerView));
+
+        // Prepare recents panel view and set the listeners
+        cardRecyclerView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                recentListGestureDetector.onTouchEvent(event);
+                return false;
+            }
+        });
+
+        mRecentPanelView = new RecentPanelView(mContext, this, cardRecyclerView, mEmptyRecentView);
+        mRecentPanelView.setOnExitListener(this);
+        mRecentPanelView.setOnTasksLoadedListener(this);
+
+        // Add finally the views and listen for outside touches.
+        mParentView.setFocusableInTouchMode(true);
+        mParentView.addView(mRecentContainer);
+        mParentView.addView(mKeyguardView);
+        mParentView.setOnTouchListener(new View.OnTouchListener() {
+            @Override
+            public boolean onTouch(View v, MotionEvent event) {
+                if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {
+                    // Touch outside the recents window....hide recents window.
+                    onExit();
+                    return true;
+                }
+                return false;
+            }
+        });
+        // Listen for back key events to close recents screen.
+        mParentView.setOnKeyListener(new View.OnKeyListener() {
+            @Override
+            public boolean onKey(View v, int keyCode, KeyEvent event) {
+                if (keyCode == KeyEvent.KEYCODE_BACK
+                    && event.getAction() == KeyEvent.ACTION_UP
+                    && !event.isCanceled()) {
+                    // Back key was pressed....hide recents window.
+                    onExit();
+                    return true;
+                }
+                return false;
+            }
+        });
+
+        // Settings observer
+        SettingsObserver observer = new SettingsObserver(mHandler);
+        observer.observe();
+    }
+
+    /**
+     * External call from theme engines to apply
+     * new styles.
+     */
+    public void rebuildRecentsScreen() {
+        // Set new layout parameters and backgrounds.
+        if (mRecentContainer != null) {
+            final ViewGroup.LayoutParams layoutParams = mRecentContainer.getLayoutParams();
+            layoutParams.width = (int) (mContext.getResources()
+                    .getDimensionPixelSize(R.dimen.recent_width) * mScaleFactor);
+            mRecentContainer.setLayoutParams(layoutParams);
+
+            setGravityAndImageResources();
+        }
+        // Rebuild complete adapter and lists to force style updates.
+        if (mRecentPanelView != null) {
+            mRecentPanelView.buildCardListAndAdapter();
+        }
+    }
+
+    /**
+     * Calculate main gravity based on layout direction and user gravity value.
+     * Set and update all resources and notify the different layouts about the change.
+     */
+    private void setGravityAndImageResources() {
+        // Calculate and set gravitiy.
+        if (mLayoutDirection == View.LAYOUT_DIRECTION_RTL) {
+            if (mUserGravity == Gravity.LEFT) {
+                mMainGravity = Gravity.RIGHT;
+            } else {
+                mMainGravity = Gravity.LEFT;
+            }
+        } else {
+            mMainGravity = mUserGravity;
+        }
+
+        // Set layout direction.
+        mRecentContainer.setLayoutDirection(mLayoutDirection);
+
+        // Reset all backgrounds.
+        mRecentContent.setBackgroundResource(0);
+        mRecentWarningContent.setBackgroundResource(0);
+        mEmptyRecentView.setImageResource(0);
+
+        // Set correct backgrounds based on calculated main gravity.
+        int warningColor = mContext.getResources().getColor(R.color.recent_warning_background);
+        mRecentWarningContent.setBackgroundColor(warningColor);
+
+        int tintColor = getEmptyRecentColor();
+        int backgroundColor = mPanelColor;
+        if (backgroundColor == 0x00ffffff) {
+            backgroundColor = mContext.getResources().getColor(R.color.recent_background);
+        }
+
+        VectorDrawable vd = (VectorDrawable)
+                mContext.getResources().getDrawable(R.drawable.ic_empty_recent);
+        vd.setTint(tintColor);
+        mEmptyRecentView.setImageDrawable(vd);
+
+        VectorDrawable kgvd = (VectorDrawable)
+                mContext.getResources().getDrawable(R.drawable.ic_recent_keyguard);
+        kgvd.setTint(tintColor);
+        mKeyguardImage.setImageDrawable(kgvd);
+        mKeyguardText.setTextColor(tintColor);
+
+        int padding = mContext.getResources().getDimensionPixelSize(R.dimen.slim_recents_elevation);
+        if (mMainGravity == Gravity.LEFT) {
+            mRecentContainer.setPadding(0, 0, padding, 0);
+            mEmptyRecentView.setRotation(180);
+        } else {
+            mRecentContainer.setPadding(padding, 0, 0, 0);
+            mEmptyRecentView.setRotation(0);
+        }
+
+        // Notify panel view about new main gravity.
+        if (mRecentPanelView != null) {
+            mRecentPanelView.setMainGravity(mMainGravity);
+        }
+
+        // Set custom background color (or reset to default, as the case may be
+        if (mRecentContent != null) {
+            mRecentContent.setElevation(50);
+            mRecentContent.setBackgroundColor(backgroundColor);
+        }
+
+        if (mKeyguardView != null) {
+            mKeyguardView.setBackgroundColor(backgroundColor);
+        }
+    }
+
+    private int getEmptyRecentColor() {
+        if (Utilities.computeContrastBetweenColors(mPanelColor,
+                Color.WHITE) < 3f) {
+            return mContext.getResources().getColor(
+                    R.color.recents_empty_dark_color);
+        } else {
+            return mContext.getResources().getColor(
+                    R.color.recents_empty_light_color);
+        }
+    }
+
+    /**
+     * External call. Toggle recents panel.
+     */
+    public void toggleRecents(Display display, int layoutDirection, View statusBarView) {
+        if (DEBUG) Log.d(TAG, "toggle recents panel");
+        if (mLayoutDirection != layoutDirection) {
+            mLayoutDirection = layoutDirection;
+            setGravityAndImageResources();
+        }
+
+        if (mAnimationState == ANIMATION_STATE_NONE) {
+            if (!isShowing()) {
+                mIsToggled = true;
+                if (mRecentPanelView.isTasksLoaded()) {
+                    if (DEBUG) Log.d(TAG, "tasks loaded - showRecents()");
+                    showRecents();
+                } else if (!mIsPreloaded) {
+                    // This should never happen due that preload should
+                    // always be done if someone calls recents. Well a lot
+                    // 3rd party apps forget the preload step. So we do it now.
+                    // Due that mIsToggled is true preloader will open the recent
+                    // screen as soon the preload is finished and the listener
+                    // notifies us that we are ready.
+                    if (DEBUG) Log.d(TAG, "preload was not called - do it now");
+                    preloadRecentTasksList();
+                }
+            } else {
+                openLastAppPanelToggle();
+                hideRecents(false);
+            }
+        }
+    }
+
+    /**
+     * External call. Preload recent tasks.
+     */
+    public void preloadRecentTasksList() {
+        if (mRecentPanelView != null) {
+            if (DEBUG) Log.d(TAG, "preloading recents");
+            mIsPreloaded = true;
+            setSystemUiVisibilityFlags();
+            mRecentPanelView.setCancelledByUser(false);
+            mRecentPanelView.loadTasks();
+        }
+    }
+
+    /**
+     * External call. Cancel preload recent tasks.
+     */
+    public void cancelPreloadingRecentTasksList() {
+        if (mRecentPanelView != null && !isShowing()) {
+            if (DEBUG) Log.d(TAG, "cancel preloading recents");
+            mIsPreloaded = false;
+            mRecentPanelView.setCancelledByUser(true);
+        }
+    }
+
+    public void closeRecents() {
+        if (DEBUG) Log.d(TAG, "closing recents panel");
+        hideRecents(false);
+    }
+
+    /**
+     * Get LayoutParams we need for the recents panel.
+     *
+     * @return LayoutParams
+     */
+    private WindowManager.LayoutParams generateLayoutParameter() {
+        final int width = (int) (mContext.getResources()
+                .getDimensionPixelSize(R.dimen.recent_width) * mScaleFactor);
+        final WindowManager.LayoutParams params = new WindowManager.LayoutParams(
+                width,
+                WindowManager.LayoutParams.MATCH_PARENT,
+                WindowManager.LayoutParams.TYPE_SLIM_RECENTS,
+                WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
+                        | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
+                        | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH
+                        | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,
+                PixelFormat.TRANSLUCENT);
+        // Turn on hardware acceleration for high end gfx devices.
+        if (ActivityManager.isHighEndGfx()) {
+            params.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
+            params.privateFlags |=
+                    WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED;
+        }
+
+        // Set gravitiy.
+        params.gravity = Gravity.CENTER_VERTICAL | mMainGravity;
+
+        // Set animation for our recent window.
+        if (mMainGravity == Gravity.LEFT) {
+            params.windowAnimations =
+                    com.android.internal.R.style.Animation_RecentScreen_Left;
+        } else {
+            params.windowAnimations = com.android.internal.R.style.Animation_RecentScreen;
+        }
+
+        // This title is for debugging only. See: dumpsys window
+        params.setTitle("RecentControlPanel");
+        return params;
+    }
+
+    /**
+     * For smooth user experience we attach the same systemui visbility
+     * flags the current app, where the user is on, has set.
+     */
+    private void setSystemUiVisibilityFlags() {
+        int vis = 0;
+        boolean layoutBehindNavigation = true;
+        int newVis = View.SYSTEM_UI_FLAG_LAYOUT_STABLE;
+        if ((vis & View.STATUS_BAR_TRANSLUCENT) != 0) {
+            newVis |= View.STATUS_BAR_TRANSLUCENT
+                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
+        }
+        if ((vis & View.NAVIGATION_BAR_TRANSLUCENT) != 0) {
+            newVis |= View.NAVIGATION_BAR_TRANSLUCENT;
+        }
+        if ((vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
+            newVis |= View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+            layoutBehindNavigation = false;
+        }
+        if ((vis & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0) {
+            newVis |= View.SYSTEM_UI_FLAG_FULLSCREEN;
+        }
+        if ((vis & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0) {
+            newVis |= View.SYSTEM_UI_FLAG_IMMERSIVE;
+            layoutBehindNavigation = false;
+        }
+        if ((vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0) {
+            newVis |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+            layoutBehindNavigation = false;
+        }
+        if (layoutBehindNavigation) {
+            newVis |= View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
+        }
+        mParentView.setSystemUiVisibility(newVis);
+    }
+
+    // Returns if panel is currently showing.
+    public boolean isShowing() {
+        return mIsShowing;
+    }
+
+    // Hide the recent window.
+    public boolean hideRecents(boolean forceHide) {
+        if (isShowing()) {
+            mIsPreloaded = false;
+            mIsToggled = false;
+            mIsShowing = false;
+            mRecentPanelView.setTasksLoaded(false);
+            mRecentPanelView.dismissPopup();
+            if (forceHide) {
+                if (DEBUG) Log.d(TAG, "force hide recent window");
+                CacheController.getInstance(mContext).setRecentScreenShowing(false);
+                mAnimationState = ANIMATION_STATE_NONE;
+                mHandler.removeCallbacks(mRecentRunnable);
+                mWindowManager.removeViewImmediate(mParentView);
+                return true;
+            } else if (mAnimationState != ANIMATION_STATE_OUT) {
+                if (DEBUG) Log.d(TAG, "out animation starting");
+                mAnimationState = ANIMATION_STATE_OUT;
+                mHandler.removeCallbacks(mRecentRunnable);
+                mHandler.postDelayed(mRecentRunnable, mContext.getResources().getInteger(
+                        com.android.internal.R.integer.config_recentDefaultDur));
+                mWindowManager.removeView(mParentView);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // Show the recent window.
+    private void showRecents() {
+        if (DEBUG) Log.d(TAG, "in animation starting");
+        mIsShowing = true;
+        sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
+        mAnimationState = ANIMATION_STATE_NONE;
+        mHandler.removeCallbacks(mRecentRunnable);
+        CacheController.getInstance(mContext).setRecentScreenShowing(true);
+        mWindowManager.addView(mParentView, generateLayoutParameter());
+        mRecentPanelView.scrollToFirst();
+
+        KeyguardManager km =
+                (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
+        if (km.inKeyguardRestrictedInputMode()) {
+            mRecentContainer.setVisibility(View.GONE);
+            mKeyguardView.setVisibility(View.VISIBLE);
+        } else {
+            mRecentContainer.setVisibility(View.VISIBLE);
+            mKeyguardView.setVisibility(View.GONE);
+        }
+    }
+
+    public static void sendCloseSystemWindows(String reason) {
+        if (ActivityManagerNative.isSystemReady()) {
+            try {
+                ActivityManagerNative.getDefault().closeSystemDialogs(reason);
+            } catch (RemoteException e) {
+            }
+        }
+    }
+
+    // Listener callback.
+    @Override
+    public void onExit() {
+        hideRecents(false);
+    }
+
+    // Listener callback.
+    @Override
+    public void onTasksLoaded() {
+        if (mIsToggled && !isShowing()) {
+            if (DEBUG) Log.d(TAG, "onTasksLoaded....showRecents()");
+            showRecents();
+        }
+    }
+
+    /**
+     * Runnable if recent panel closed to notify the cache controller about the state.
+     */
+    private final Runnable mRecentRunnable = new Runnable() {
+        @Override
+        public void run() {
+            if (mAnimationState == ANIMATION_STATE_OUT) {
+                if (DEBUG) Log.d(TAG, "out animation finished");
+                CacheController.getInstance(mContext).setRecentScreenShowing(false);
+            }
+            mAnimationState = ANIMATION_STATE_NONE;
+        }
+    };
+
+    /**
+     * Settingsobserver to take care of the user settings.
+     * Either gravity or scale factor of our recent panel can change.
+     */
+    private class SettingsObserver extends UserContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        @Override
+        protected void observe() {
+            super.observe();
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.RECENT_PANEL_GRAVITY),
+                    false, this, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.RECENT_PANEL_SCALE_FACTOR),
+                    false, this, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.RECENT_PANEL_EXPANDED_MODE),
+                    false, this, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.RECENT_PANEL_SHOW_TOPMOST),
+                    false, this, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.RECENT_PANEL_BG_COLOR),
+                    false, this, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.RECENT_SHOW_RUNNING_TASKS),
+                    false, this, UserHandle.USER_ALL);
+            update();
+        }
+
+        @Override
+        protected void update() {
+            // Close recent panel if it is opened.
+            hideRecents(false);
+
+            ContentResolver resolver = mContext.getContentResolver();
+
+            // Get user gravity.
+            mUserGravity = Settings.System.getIntForUser(
+                    resolver, Settings.System.RECENT_PANEL_GRAVITY, Gravity.RIGHT,
+                    UserHandle.USER_CURRENT);
+
+            // Update colors in RecentPanelView
+            mPanelColor = Settings.System.getIntForUser(resolver,
+                    Settings.System.RECENT_PANEL_BG_COLOR, 0x763367d6, UserHandle.USER_CURRENT);
+
+            // Set main gravity and background images.
+            setGravityAndImageResources();
+
+            // Get user scale factor.
+            float scaleFactor = Settings.System.getIntForUser(
+                    resolver, Settings.System.RECENT_PANEL_SCALE_FACTOR, 100,
+                    UserHandle.USER_CURRENT) / 100.0f;
+
+            // If changed set new scalefactor, rebuild the recent panel
+            // and notify RecentPanelView about new value.
+            if (scaleFactor != mScaleFactor) {
+                mScaleFactor = scaleFactor;
+                rebuildRecentsScreen();
+            }
+            if (mRecentPanelView != null) {
+                mRecentPanelView.setScaleFactor(mScaleFactor);
+                mRecentPanelView.setExpandedMode(Settings.System.getIntForUser(
+                    resolver, Settings.System.RECENT_PANEL_EXPANDED_MODE,
+                    mRecentPanelView.EXPANDED_MODE_AUTO,
+                    UserHandle.USER_CURRENT));
+                mRecentPanelView.setShowTopTask(Settings.System.getIntForUser(
+                    resolver, Settings.System.RECENT_PANEL_SHOW_TOPMOST, 0,
+                    UserHandle.USER_CURRENT) == 1);
+                mRecentPanelView.setShowOnlyRunningTasks(Settings.System.getIntForUser(
+                    resolver, Settings.System.RECENT_SHOW_RUNNING_TASKS, 0,
+                    UserHandle.USER_CURRENT) == 1);
+            }
+
+            mRecentContent.setElevation(50);
+
+            int backgroundColor = mPanelColor;
+            if (backgroundColor == 0x00ffffff) {
+                backgroundColor = mContext.getResources().getColor(R.color.recent_background);
+            }
+            mRecentContent.setBackgroundColor(backgroundColor);
+            mKeyguardView.setBackgroundColor(backgroundColor);
+        }
+    }
+
+    /**
+     * Extended SimpleOnScaleGestureListener to take
+     * care of a pinch to zoom out gesture. This class
+     * takes as well care on a bunch of animations which are needed
+     * to control the final action.
+     */
+    private class RecentListOnScaleGestureListener extends SimpleOnScaleGestureListener {
+
+        // Constants for scaling max/min values.
+        private final static float MAX_SCALING_FACTOR       = 1.0f;
+        private final static float MIN_SCALING_FACTOR       = 0.5f;
+        private final static float MIN_ALPHA_SCALING_FACTOR = 0.55f;
+
+        private final static int ANIMATION_FADE_IN_DURATION  = 400;
+        private final static int ANIMATION_FADE_OUT_DURATION = 300;
+
+        private float mScalingFactor = MAX_SCALING_FACTOR;
+        private boolean mActionDetected;
+
+        // Views we need and are passed trough the constructor.
+        private LinearLayout mRecentWarningContent;
+        private CardRecyclerView mCardRecyclerView;
+
+        RecentListOnScaleGestureListener(
+                LinearLayout recentWarningContent, CardRecyclerView cardRecyclerView) {
+            mRecentWarningContent = recentWarningContent;
+            mCardRecyclerView = cardRecyclerView;
+        }
+
+        @Override
+        public boolean onScale(ScaleGestureDetector detector) {
+            // Get gesture scaling factor and calculate the values we need.
+            mScalingFactor *= detector.getScaleFactor();
+            mScalingFactor = Math.max(MIN_SCALING_FACTOR,
+                    Math.min(mScalingFactor, MAX_SCALING_FACTOR));
+            final float alphaValue = Math.max(MIN_ALPHA_SCALING_FACTOR,
+                    Math.min(mScalingFactor, MAX_SCALING_FACTOR));
+
+            // Reset detection value.
+            mActionDetected = false;
+
+            // Set alpha value for content.
+            mRecentContent.setAlpha(alphaValue);
+
+            // Check if we are under MIN_ALPHA_SCALING_FACTOR and show
+            // warning view.
+            if (mScalingFactor < MIN_ALPHA_SCALING_FACTOR) {
+                mActionDetected = true;
+                mRecentWarningContent.setVisibility(View.VISIBLE);
+            } else {
+                mRecentWarningContent.setVisibility(View.GONE);
+            }
+            return true;
+        }
+
+        @Override
+        public boolean onScaleBegin(ScaleGestureDetector detector) {
+            return mRecentPanelView.hasClearableTasks();
+        }
+
+        @Override
+        public void onScaleEnd(ScaleGestureDetector detector) {
+            super.onScaleEnd(detector);
+            // Reset to default scaling factor to prepare for next gesture.
+            mScalingFactor = MAX_SCALING_FACTOR;
+
+            final float currentAlpha = mRecentContent.getAlpha();
+
+            // Gesture was detected and activated. Prepare and play the animations.
+            if (mActionDetected) {
+                final boolean hasFavorite = mRecentPanelView.hasFavorite();
+
+                // Setup animation for warning content - fade out.
+                ValueAnimator animation1 = ValueAnimator.ofFloat(0.7f, 0.0f);
+                animation1.setDuration(ANIMATION_FADE_OUT_DURATION);
+                animation1.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                    @Override
+                    public void onAnimationUpdate(ValueAnimator animation) {
+                        mRecentWarningContent.setAlpha((Float) animation.getAnimatedValue());
+                    }
+                });
+
+                // Setup animation for list view - fade out.
+                ValueAnimator animation2 = ValueAnimator.ofFloat(1.0f, 0.0f);
+                animation2.setDuration(ANIMATION_FADE_OUT_DURATION);
+                animation2.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                    @Override
+                    public void onAnimationUpdate(ValueAnimator animation) {
+                        mCardRecyclerView.setAlpha((Float) animation.getAnimatedValue());
+                    }
+                });
+
+                // Setup animation for base content - fade in.
+                ValueAnimator animation3 = ValueAnimator.ofFloat(currentAlpha, 1.0f);
+                animation3.setDuration(ANIMATION_FADE_IN_DURATION);
+                animation3.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                    @Override
+                    public void onAnimationUpdate(ValueAnimator animation) {
+                        mRecentContent.setAlpha((Float) animation.getAnimatedValue());
+                    }
+                });
+
+                // Setup animation for empty recent image - fade in.
+                if (!hasFavorite) {
+                    mEmptyRecentView.setAlpha(0.0f);
+                    mEmptyRecentView.setVisibility(View.VISIBLE);
+                }
+                ValueAnimator animation4 = ValueAnimator.ofFloat(0.0f, 1.0f);
+                animation4.setDuration(ANIMATION_FADE_IN_DURATION);
+                animation4.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                    @Override
+                    public void onAnimationUpdate(ValueAnimator animation) {
+                        mEmptyRecentView.setAlpha((Float) animation.getAnimatedValue());
+                    }
+                });
+
+                // Start all ValueAnimator animations
+                // and listen onAnimationEnd to prepare the views for the next call.
+                AnimatorSet animationSet = new AnimatorSet();
+                if (hasFavorite) {
+                    animationSet.playTogether(animation1, animation3);
+                } else {
+                    animationSet.playTogether(animation1, animation2, animation3, animation4);
+                }
+                animationSet.addListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        // Animation is finished. Prepare warning content for next call.
+                        mRecentWarningContent.setVisibility(View.GONE);
+                        mRecentWarningContent.setAlpha(0.7f);
+                        // Remove all tasks now.
+                        if (mRecentPanelView.removeAllApplications()) {
+                            // Prepare listview for next recent call.
+                            mCardRecyclerView.setVisibility(View.GONE);
+                            mCardRecyclerView.setAlpha(1.0f);
+                            // Finally hide our recents screen.
+                            hideRecents(false);
+                        }
+                    }
+                });
+                animationSet.start();
+
+            } else if (currentAlpha < 1.0f) {
+                // No gesture action was detected. But we may have a lower alpha
+                // value for the content. Animate back to full opacitiy.
+                ValueAnimator animation = ValueAnimator.ofFloat(currentAlpha, 1.0f);
+                animation.setDuration(100);
+                animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+                    @Override
+                    public void onAnimationUpdate(ValueAnimator animation) {
+                        mRecentContent.setAlpha((Float) animation.getAnimatedValue());
+                    }
+                });
+                animation.start();
+            }
+        }
+   }
+
+    public void startMultiWin() {
+        SystemServicesProxy ssp = SystemServicesProxy.getInstance(mContext);
+        ActivityManager.RunningTaskInfo runningTask = ssp.getRunningTask();
+        int createMode = ActivityManager.DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT;
+        if (ssp.startTaskInDockedMode(runningTask.id, createMode)) {
+            openLastApptoBottom();
+            if (!isShowing()) {
+                showRecents();
+            }
+        }
+   }
+
+    public void openLastApptoBottom() {
+        final ActivityManager am =
+                (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager.RunningTaskInfo lastTask = getLastTask(am);
+
+        if (lastTask != null) {
+            am.moveTaskToFront(lastTask.id, ActivityManager.MOVE_TASK_NO_USER_ACTION);
+        }
+    }
+
+    public void openOnDraggedApptoOtherSide(int taskid) {
+        final ActivityManager am =
+                (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+
+        am.moveTaskToFront(taskid, ActivityManager.MOVE_TASK_NO_USER_ACTION);
+    }
+
+    public void openLastAppPanelToggle() {
+        final ActivityOptions animations = ActivityOptions.makeCustomAnimation(mContext,
+                mMainGravity == Gravity.LEFT ? com.android.internal.R.anim.recent_screen_enter_left :
+                com.android.internal.R.anim.recent_screen_enter,
+                com.android.internal.R.anim.recent_screen_fade_out);
+        final ActivityManager am =
+                (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        ActivityManager.RunningTaskInfo lastTask = getLastTask(am);
+
+        if (lastTask != null) {
+            am.moveTaskToFront(lastTask.id, ActivityManager.MOVE_TASK_NO_USER_ACTION, animations.toBundle());
+        }
+    }
+
+    private ActivityManager.RunningTaskInfo getLastTask(final ActivityManager am) {
+        final String defaultHomePackage = resolveCurrentLauncherPackage();
+        List<ActivityManager.RunningTaskInfo> tasks = am.getRunningTasks(5);
+
+        for (int i = 1; i < tasks.size(); i++) {
+            String packageName = tasks.get(i).topActivity.getPackageName();
+            if (!packageName.equals(defaultHomePackage)
+                    && !packageName.equals(mContext.getPackageName())
+                    && !packageName.equals("com.android.systemui")) {
+                return tasks.get(i);
+            }
+        }
+        return null;
+    }
+
+    private String resolveCurrentLauncherPackage() {
+        final Intent launcherIntent = new Intent(Intent.ACTION_MAIN)
+                .addCategory(Intent.CATEGORY_HOME);
+        final PackageManager pm = mContext.getPackageManager();
+        final ResolveInfo launcherInfo = pm.resolveActivity(launcherIntent, 0);
+        return launcherInfo.activityInfo.packageName;
+    }
+
+    private class CacheMoreCardsLayoutManager extends LinearLayoutManager {
+        private Context context;
+        private WindowManager mWindowManager;
+
+        public CacheMoreCardsLayoutManager(Context context, WindowManager windowManager) {
+            super(context);
+            this.context = context;
+            this.mWindowManager = windowManager;
+        }
+
+        @Override
+        protected int getExtraLayoutSpace(RecyclerView.State state) {
+            return getScreenHeight();
+        }
+
+        private int getScreenHeight() {
+            Display display = mWindowManager.getDefaultDisplay();
+            Point size = new Point();
+            display.getSize(size);
+            int screenHeight = size.y;
+            return screenHeight;
+        }
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentExpandedCard.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentExpandedCard.java
new file mode 100644
index 00000000000..0969d4698aa
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentExpandedCard.java
@@ -0,0 +1,387 @@
+/*
+ * Copyright (C) 2014-2017 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.Config;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.graphics.Paint;
+import android.graphics.RectF;
+import android.os.AsyncTask;
+import android.os.ParcelFileDescriptor;
+import android.os.Process;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.android.cards.internal.CardExpand;
+import com.android.systemui.R;
+
+import java.io.IOException;
+import java.lang.ref.WeakReference;
+
+/**
+ * This class handles our expanded card which shows the actual task screenshot.
+ * The loader (#link:BitmapDownloaderTask) class is handled here as well and put
+ * the loaded task screenshot for the time the task exists into the LRU cache.
+ */
+public class RecentExpandedCard extends CardExpand {
+
+    private Context mContext;
+
+    private Drawable mDefaultThumbnailBackground;
+
+    private int mPersistentTaskId = -1;
+    private String mLabel;
+    private int mThumbnailWidth;
+    private int mThumbnailHeight;
+    private int mBottomPadding;
+    private float mScaleFactor;
+    private boolean mScaleFactorChanged;
+
+    private int defaultCardBg;
+    //private int cardColor;
+
+    private BitmapDownloaderTask mTask;
+
+    private boolean mReload;
+    private boolean mDoNotNullBitmap;
+
+    final static BitmapFactory.Options sBitmapOptions;
+
+    private TaskDescription mTaskDescription;
+
+    static {
+        sBitmapOptions = new BitmapFactory.Options();
+        sBitmapOptions.inMutable = true;
+    }
+
+    public RecentExpandedCard(Context context, TaskDescription td, float scaleFactor) {
+        this(context, R.layout.recent_inner_card_expand, td, scaleFactor);
+    }
+
+    // Main constructor. Set the important values we need.
+    public RecentExpandedCard(Context context, int innerLayout,
+            TaskDescription td, float scaleFactor) {
+        super(context, innerLayout);
+        mTaskDescription = td;
+        mContext = context;
+        mPersistentTaskId = td.persistentTaskId;
+        mLabel = (String) td.getLabel();
+        mScaleFactor = scaleFactor;
+
+        defaultCardBg = mContext.getResources().getColor(
+                R.color.recents_task_bar_default_background_color);
+
+        initDimensions();
+    }
+
+    // Update expanded card content.
+    public void updateExpandedContent(TaskDescription td, float scaleFactor) {
+        mTaskDescription = td;
+        String label = (String) td.getLabel();
+        if (label != null && label.equals(mLabel)) {
+            mDoNotNullBitmap = true;
+        }
+        mLabel = label;
+        mPersistentTaskId = td.persistentTaskId;
+        mReload = true;
+
+        if (scaleFactor != mScaleFactor) {
+            mScaleFactorChanged = true;
+            mScaleFactor = scaleFactor;
+            initDimensions();
+        }
+    }
+
+    /** Returns the activity's primary color. */
+    public int getDefaultCardColorBg() {
+        if (mTaskDescription != null && mTaskDescription.cardColor != 0) {
+            return mTaskDescription.cardColor;
+        }
+        return defaultCardBg;
+    }
+
+    // Setup main dimensions we need.
+    private void initDimensions() {
+        final Resources res = mContext.getResources();
+        // Render the default thumbnail background
+        mThumbnailWidth = (int) (res.getDimensionPixelSize(
+                R.dimen.recent_thumbnail_width) * mScaleFactor);
+        mThumbnailHeight = (int) (res.getDimensionPixelSize(
+                R.dimen.recent_thumbnail_height) * mScaleFactor);
+        mBottomPadding = (int) (res.getDimensionPixelSize(
+                R.dimen.recent_thumbnail_bottom_padding) * mScaleFactor);
+
+        mDefaultThumbnailBackground = new ColorDrawableWithDimensions(
+                res.getColor(R.color.card_backgroundExpand), mThumbnailWidth, mThumbnailHeight);
+    }
+
+    @Override
+    public void setupInnerViewElements(ViewGroup parent, View view) {
+        if (view == null || mPersistentTaskId == -1) {
+            return;
+        }
+
+        // We use here a view holder to reduce expensive findViewById calls
+        // when getView is called on the arrayadapter which calls setupInnerViewElements.
+        // Simply just check if the given view was already tagged. If yes we know it has
+        // the thumbnailView we want to have. If not we search it, give it to the viewholder
+        // and tag the view for the next call to reuse the holded information later.
+        ViewHolder holder;
+        holder = (ViewHolder) view.getTag();
+
+        if (holder == null) {
+            holder = new ViewHolder();
+            holder.thumbnailView = (RecentImageView) view.findViewById(R.id.thumbnail);
+            // Take scale factor into account if it is different then default or it has changed.
+            if (mScaleFactor != RecentController.DEFAULT_SCALE_FACTOR || mScaleFactorChanged) {
+                mScaleFactorChanged = false;
+                final ViewGroup.MarginLayoutParams layoutParams =
+                        (ViewGroup.MarginLayoutParams) holder.thumbnailView.getLayoutParams();
+                layoutParams.width = mThumbnailWidth;
+                layoutParams.height = mThumbnailHeight;
+                layoutParams.setMargins(0, 0, 0, mBottomPadding);
+                holder.thumbnailView.setLayoutParams(layoutParams);
+            }
+            view.setTag(holder);
+        }
+
+        // Assign task bitmap to our view via async task loader. If it is just
+        // a refresh of the view do not load it again
+        // and use the allready present one from the LRU Cache.
+        if (mTask == null || mReload) {
+            if (!mDoNotNullBitmap) {
+                holder.thumbnailView.setImageDrawable(mDefaultThumbnailBackground);
+            }
+
+            mReload = false;
+            mDoNotNullBitmap = false;
+
+            mTask = new BitmapDownloaderTask(holder.thumbnailView, mContext, mScaleFactor);
+            mTask.executeOnExecutor(
+                    AsyncTask.THREAD_POOL_EXECUTOR, mPersistentTaskId);
+        } else {
+            if (mTask.isLoaded()) {
+                // We may have lost our thumbnail in our cache.
+                // Check for it. If it is not present reload it again.
+                Bitmap bitmap = CacheController.getInstance(mContext)
+                        .getBitmapFromMemCache(String.valueOf(mPersistentTaskId));
+
+                if (bitmap == null) {
+                    mTask = new BitmapDownloaderTask(holder.thumbnailView, mContext, mScaleFactor);
+                    mTask.executeOnExecutor(
+                            AsyncTask.THREAD_POOL_EXECUTOR, mPersistentTaskId);
+                } else {
+                    holder.thumbnailView.setImageBitmap(CacheController.getInstance(mContext)
+                            .getBitmapFromMemCache(String.valueOf(mPersistentTaskId)));
+                }
+            }
+        }
+
+        parent.setBackgroundColor(getDefaultCardColorBg());
+    }
+
+    static class ViewHolder {
+        RecentImageView thumbnailView;
+    }
+
+    // Loads the actual task bitmap.
+    private static Bitmap loadThumbnail(int persistentTaskId, Context context, float scaleFactor) {
+        if (context == null) {
+            return null;
+        }
+        final ActivityManager am = (ActivityManager)
+                context.getSystemService(Context.ACTIVITY_SERVICE);
+        return getResizedBitmap(getThumbnail(am, persistentTaskId), context, scaleFactor);
+    }
+
+    /**
+     * Returns a task thumbnail from the activity manager
+     */
+    public static Bitmap getThumbnail(ActivityManager activityManager, int taskId) {
+        ActivityManager.TaskThumbnail taskThumbnail = activityManager.getTaskThumbnail(taskId);
+        if (taskThumbnail == null) return null;
+
+        Bitmap thumbnail = taskThumbnail.mainThumbnail;
+        ParcelFileDescriptor descriptor = taskThumbnail.thumbnailFileDescriptor;
+        if (thumbnail == null && descriptor != null) {
+            thumbnail = BitmapFactory.decodeFileDescriptor(descriptor.getFileDescriptor(),
+                    null, sBitmapOptions);
+        }
+        if (descriptor != null) {
+            try {
+                descriptor.close();
+            } catch (IOException e) {
+            }
+        }
+        return thumbnail;
+    }
+
+    // Resize and crop the task bitmap to the overlay values.
+    private static Bitmap getResizedBitmap(Bitmap source, Context context, float scaleFactor) {
+        if (source == null) {
+            return null;
+        }
+
+        final Resources res = context.getResources();
+        final int thumbnailWidth =
+                (int) (res.getDimensionPixelSize(
+                        R.dimen.recent_thumbnail_width) * scaleFactor);
+        final int thumbnailHeight =
+                (int) (res.getDimensionPixelSize(
+                        R.dimen.recent_thumbnail_height) * scaleFactor);
+        final float INITIAL_SCALE = 0.75f;
+        int h = source.getHeight();
+        int w = source.getWidth();
+        Bitmap cropped = null;
+
+        int mode = currentHandsMode(context);
+        try {
+            if (mode == 1) {
+                cropped = Bitmap.createBitmap(source, 0, (int)(h * (1-INITIAL_SCALE)),
+                        (int)(w * INITIAL_SCALE), (int)(h * INITIAL_SCALE));
+                source.recycle();
+                source = null;
+            } else if (mode == 2) {
+                cropped = Bitmap.createBitmap(source, (int)(w * (1-INITIAL_SCALE)), (int)(h * (1-INITIAL_SCALE)),
+                        (int)(w * INITIAL_SCALE), (int)(h * INITIAL_SCALE));
+                source.recycle();
+                source = null;
+            }
+        } catch (Exception e) {
+            cropped = source;
+            source.recycle();
+            source = null;
+        }
+
+        final int sourceWidth = mode != 0 ? cropped.getWidth() : w;
+        final int sourceHeight = mode != 0 ? cropped.getHeight() : h;
+
+        // Compute the scaling factors to fit the new height and width, respectively.
+        // To cover the final image, the final scaling will be the bigger
+        // of these two.
+        final float xScale = (float) thumbnailWidth / sourceWidth;
+        final float yScale = (float) thumbnailHeight / sourceHeight;
+        final float scale = Math.max(xScale, yScale);
+
+        // Now get the size of the source bitmap when scaled
+        final float scaledWidth = scale * sourceWidth;
+        final float scaledHeight = scale * sourceHeight;
+
+        // Let's find out the left coordinates if the scaled bitmap
+        // should be centered in the new size given by the parameters
+        final float left = (thumbnailWidth - scaledWidth) / 2;
+
+        // The target rectangle for the new, scaled version of the source bitmap
+        final RectF targetRect = new RectF(left, 0.0f, left + scaledWidth, scaledHeight);
+
+        final Paint paint = new Paint(Paint.FILTER_BITMAP_FLAG);
+        paint.setAntiAlias(true);
+
+        // Finally, we create a new bitmap of the specified size and draw our new,
+        // scaled bitmap onto it.
+        final Bitmap dest = Bitmap.createBitmap(thumbnailWidth, thumbnailHeight, Config.ARGB_8888);
+        final Canvas canvas = new Canvas(dest);
+        canvas.drawBitmap(mode != 0 ? cropped : source, null, targetRect, paint);
+
+        return dest;
+    }
+
+    private static int currentHandsMode(Context context) {
+        int mode;
+        String str = Settings.Global.getString(context.getContentResolver(),
+                Settings.Global.SINGLE_HAND_MODE);
+        if (str != null && str.contains("left")) {
+            mode = 1;
+        } else if (str != null && str.contains("right")) {
+            mode = 2;
+        } else {
+            mode = 0;
+        }
+        return mode;
+    }
+
+    // AsyncTask loader for the task bitmap.
+    private static class BitmapDownloaderTask extends AsyncTask<Integer, Void, Bitmap> {
+
+        private boolean mLoaded;
+
+        private final WeakReference<RecentImageView> rImageViewReference;
+        private final WeakReference<Context> rContext;
+
+        //private int mOrigPri;
+        private float mScaleFactor;
+
+        private String mLRUCacheKey;
+
+        public BitmapDownloaderTask(RecentImageView imageView,
+                Context context, float scaleFactor) {
+            rImageViewReference = new WeakReference<RecentImageView>(imageView);
+            rContext = new WeakReference<Context>(context);
+            mScaleFactor = scaleFactor;
+        }
+
+        @Override
+        protected Bitmap doInBackground(Integer... params) {
+            mLoaded = false;
+            mLRUCacheKey = null;
+            Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
+            if (isCancelled() || rContext == null) {
+                return null;
+            }
+            mLRUCacheKey = String.valueOf(params[0]);
+            // Load and return bitmap
+            return loadThumbnail(params[0], rContext.get(), mScaleFactor);
+        }
+
+        @Override
+        protected void onPostExecute(Bitmap bitmap) {
+            if (isCancelled()) {
+                bitmap = null;
+            }
+
+            // Assign image to the view.
+            if (rImageViewReference != null) {
+                mLoaded = true;
+                final RecentImageView imageView = rImageViewReference.get();
+                if (imageView != null) {
+                    imageView.setImageBitmap(bitmap);
+                    if (bitmap != null && rContext != null) {
+                        final Context context = rContext.get();
+                        if (context != null) {
+                            // Put the loaded bitmap into the LRU cache for later use.
+                            CacheController.getInstance(context)
+                                    .addBitmapToMemoryCache(mLRUCacheKey, bitmap);
+                        }
+                    }
+                }
+            }
+        }
+
+        public boolean isLoaded() {
+            return mLoaded;
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentHeader.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentHeader.java
new file mode 100644
index 00000000000..ad3caffa321
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentHeader.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2014-2017 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.util.TypedValue;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageButton;
+import android.widget.TextView;
+
+import com.android.cards.internal.CardHeader;
+import com.android.systemui.R;
+import com.android.systemui.recents.misc.Utilities;
+
+import android.graphics.Typeface;
+
+/**
+ * This class handles the header view.
+ */
+public class RecentHeader extends CardHeader {
+
+    private Context mContext;
+
+    private TaskDescription mTaskDescription;
+
+    private String mLabel;
+    private int mHeaderHeight;
+    private int mHeaderWidth;
+    private float mHeaderTextSize;
+    private float mHeaderTextSizeBigPanel;
+    private int mExpandedButtonWidth;
+    private float mScaleFactor;
+
+    public RecentHeader(Context context, TaskDescription td, float scaleFactor) {
+        super(context);
+        mTaskDescription = td;
+        mContext = context;
+        mLabel = td.getLabel();
+        mScaleFactor = scaleFactor;
+        initDimensions();
+
+        Drawable d = mContext.getResources().getDrawable(R.drawable.card_menu_button_expand);
+        mExpandedButtonWidth = d.getIntrinsicWidth();
+    }
+
+    // Update header content.
+    public void updateHeader(TaskDescription td, float scaleFactor) {
+        mTaskDescription = td;
+        mLabel = td.getLabel();
+        if (scaleFactor != mScaleFactor) {
+            mScaleFactor = scaleFactor;
+            initDimensions();
+        }
+
+    }
+
+    // Set initial dimensions.
+    private void initDimensions() {
+        Resources res = mContext.getResources();
+        mHeaderHeight = (int) (res.getDimensionPixelSize(
+                R.dimen.recent_app_icon_size) * mScaleFactor);
+        mHeaderWidth = (int) (res.getDimensionPixelSize(
+                R.dimen.recent_header_width) * mScaleFactor);
+        mHeaderTextSize = res.getDimensionPixelSize(
+                R.dimen.recent_text_size) * mScaleFactor;
+        mHeaderTextSizeBigPanel = res.getDimensionPixelSize(
+                R.dimen.recent_text_size);
+    }
+
+    /**
+     * Assign the label to the view.
+     */
+    @Override
+    public void setupInnerViewElements(ViewGroup parent, View view) {
+        if (view == null || mLabel == null) {
+            return;
+        }
+
+        // We use here a view holder to reduce expensive findViewById calls
+        // when getView is called on the arrayadapter which calls setupInnerViewElements.
+        // Simply just check if the given view was already tagged. If yes we know it has
+        // the appIconView we want to have. If not we search it, give it to the viewholder
+        // and tag the view for the next call to reuse the holded information later.
+        ViewHolder holder;
+        holder = (ViewHolder) view.getTag();
+
+        if (holder == null) {
+            holder = new ViewHolder();
+            holder.textView = (TextView) view.findViewById(R.id.card_header_inner_simple_title);
+            holder.expandButton = (ImageButton) ((View)view.getParent().getParent())
+                    .findViewById(R.id.card_header_button_expand);
+            // Take scale factor into account if it is different then default or it has changed.
+
+            if (mScaleFactor < RecentController.DEFAULT_SCALE_FACTOR) {
+                int diff = 0;
+                // We have on static element in the header (expanded icon button). Take this into
+                // account to calculate the needed width.
+                diff = (int) ((mExpandedButtonWidth - mExpandedButtonWidth * mScaleFactor) * 2);
+                final ViewGroup.LayoutParams layoutParams = holder.textView.getLayoutParams();
+                layoutParams.width = mHeaderWidth - diff;
+                layoutParams.height = mHeaderHeight;
+                holder.textView.setLayoutParams(layoutParams);
+                holder.textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, mHeaderTextSize);
+            } else {
+                holder.textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, mHeaderTextSizeBigPanel);
+            }
+            view.setTag(holder);
+        }
+        holder.textView.setText(mLabel);
+        int textColor = getDefaultTextColor();
+        Typeface font = Typeface.create("sans-serif-condensed", Typeface.BOLD);
+        holder.textView.setTypeface(font);
+        holder.textView.setTextColor(textColor);
+        if (holder.expandButton != null) {
+            holder.expandButton.setColorFilter(textColor);
+        }
+    }
+
+    public int getDefaultTextColor() {
+        if (mTaskDescription.cardColor != 0) {
+            if (Utilities.computeContrastBetweenColors(mTaskDescription.cardColor,
+                    Color.WHITE) < 3f) {
+                return mContext.getResources().getColor(
+                        R.color.recents_task_bar_dark_text_color);
+            } else {
+                return mContext.getResources().getColor(
+                        R.color.recents_task_bar_light_text_color);
+            }
+        }
+        return mContext.getResources().getColor(
+                    R.color.card_text_color_header);
+    }
+
+    static class ViewHolder {
+        TextView textView;
+        ImageButton expandButton;
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentImageView.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentImageView.java
new file mode 100644
index 00000000000..4bf035aa525
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentImageView.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2014-2016 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.util.AttributeSet;
+import android.widget.ImageView;
+
+/**
+ * Thanks to a google post from Jorim Jaggy I saw
+ * this nice trick to reduce requestLayout calls.
+ *
+ * https://plus.google.com/+JorimJaggi/posts/iTk4PjgeAWX
+ *
+ * We handle in SlimRecent always exactly same measured
+ * bitmaps and drawables. So we do not need a
+ * requestLayout call at all when we use setImageBitmap
+ * or setImageDrawable. Due that setImageBitmap directly
+ * calls setImageDrawable (#link:ImageView) it is enough
+ * to block this behaviour on setImageDrawable.
+ */
+
+public class RecentImageView extends ImageView {
+    private boolean mBlockLayout;
+
+    public RecentImageView(Context context) {
+        super(context);
+    }
+
+    public RecentImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public RecentImageView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+    }
+
+    @Override
+    public void requestLayout() {
+        if (!mBlockLayout) {
+            super.requestLayout();
+        }
+    }
+
+    @Override
+    public void setImageDrawable(Drawable drawable) {
+        mBlockLayout = true;
+        super.setImageDrawable(drawable);
+        mBlockLayout = false;
+    }
+
+    @Override
+    public void draw(Canvas canvas) {
+        // For security reasons if it was recycled and we do not
+        // know it. This should never happen. So just in case.
+        Drawable drawable = getDrawable();
+        if (drawable != null && drawable instanceof BitmapDrawable) {
+            Bitmap bitmap = ((BitmapDrawable)drawable).getBitmap();
+            if (bitmap != null && bitmap.isRecycled()) {
+                return;
+            }
+        }
+        super.draw(canvas);
+    }
+
+}
+
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/RecentPanelView.java b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentPanelView.java
new file mode 100644
index 00000000000..09777240a78
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/RecentPanelView.java
@@ -0,0 +1,1034 @@
+/*
+ * Copyright (C) 2014-2017 SlimRoms Project
+ * Author: Lars Greiss - email: kufikugel@googlemail.com
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.app.Activity;
+import android.app.ActivityManager;
+import android.app.ActivityManagerNative;
+import android.app.ActivityOptions;
+import android.app.TaskStackBuilder;
+import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.pm.ResolveInfo;
+import android.net.Uri;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Process;
+import android.os.RemoteException;
+import android.os.UserHandle;
+import android.provider.Settings;
+import android.support.v7.widget.LinearLayoutManager;
+import android.support.v7.widget.RecyclerView;
+import android.support.v7.widget.RecyclerView.ViewHolder;
+import android.support.v7.widget.helper.ItemTouchHelper;
+import android.util.Log;
+import android.view.accessibility.AccessibilityEvent;
+import android.view.ContextThemeWrapper;
+import android.view.Gravity;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.WindowManager;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.Toast;
+
+import com.android.cards.recyclerview.internal.BaseRecyclerViewAdapter.CardViewHolder;
+import com.android.cards.recyclerview.internal.CardArrayRecyclerViewAdapter;
+import com.android.cards.recyclerview.view.CardRecyclerView;
+import com.android.cards.internal.Card;
+import com.android.systemui.R;
+import com.android.systemui.stackdivider.WindowManagerProxy;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Our main view controller which handles and construct most of the view
+ * related tasks.
+ *
+ * Constructing the actual cards, add the listeners, loading or updating the tasks
+ * and inform all relevant classes with the listeners is done here.
+ *
+ * As well the actual click, longpress or swipe action methods are holded here.
+ */
+public class RecentPanelView {
+
+    private static final String TAG = "RecentPanelView";
+    public static final boolean DEBUG = false;
+
+    public static final String TASK_PACKAGE_IDENTIFIER = "#ident:";
+
+    private static final int EXPANDED_STATE_UNKNOWN  = 0;
+    public static final int EXPANDED_STATE_EXPANDED  = 1;
+    public static final int EXPANDED_STATE_COLLAPSED = 2;
+    public static final int EXPANDED_STATE_BY_SYSTEM = 4;
+    public static final int EXPANDED_STATE_TOPTASK   = 8;
+
+    public static final int EXPANDED_MODE_AUTO    = 0;
+    private static final int EXPANDED_MODE_ALWAYS = 1;
+    private static final int EXPANDED_MODE_NEVER  = 2;
+
+    private static final int MENU_APP_DETAILS_ID   = 0;
+    private static final int MENU_APP_PLAYSTORE_ID = 1;
+    private static final int MENU_APP_AMAZON_ID    = 2;
+
+    public static final String PLAYSTORE_REFERENCE = "com.android.vending";
+    public static final String AMAZON_REFERENCE    = "com.amazon.venezia";
+
+    public static final String PLAYSTORE_APP_URI_QUERY = "market://details?id=";
+    public static final String AMAZON_APP_URI_QUERY    = "amzn://apps/android?p=";
+
+    private final Context mContext;
+    private final ImageView mEmptyRecentView;
+
+    private final CardRecyclerView mCardRecyclerView;
+    private CardArrayRecyclerViewAdapter mCardAdapter;
+
+    private final RecentController mController;
+
+    // Array list of all current cards
+    private ArrayList<Card> mCards;
+    // Our first task which is not displayed but needed for internal references.
+    protected TaskDescription mFirstTask;
+    // Array list of all expanded states of apps accessed during the session
+    private final ArrayList<TaskExpandedStates> mExpandedTaskStates =
+            new ArrayList<TaskExpandedStates>();
+
+    private boolean mCancelledByUser;
+    private boolean mTasksLoaded;
+    private boolean mIsLoading;
+
+    private int mMainGravity;
+    private float mScaleFactor;
+    private int mExpandedMode = EXPANDED_MODE_AUTO;
+    private boolean mShowTopTask;
+    private boolean mOnlyShowRunningTasks;
+
+    public interface OnExitListener {
+        void onExit();
+    }
+    private OnExitListener mOnExitListener = null;
+
+    public void setOnExitListener(OnExitListener onExitListener) {
+        mOnExitListener = onExitListener;
+    }
+
+    public interface OnTasksLoadedListener {
+        void onTasksLoaded();
+    }
+    private OnTasksLoadedListener mOnTasksLoadedListener = null;
+
+    public void setOnTasksLoadedListener(OnTasksLoadedListener onTasksLoadedListener) {
+        mOnTasksLoadedListener = onTasksLoadedListener;
+    }
+
+    public RecentPanelView(Context context, RecentController controller,
+            CardRecyclerView recyclerView, ImageView emptyRecentView) {
+        mContext = context;
+        mCardRecyclerView = recyclerView;
+        mEmptyRecentView = emptyRecentView;
+        mController = controller;
+
+        buildCardListAndAdapter();
+
+        setupItemTouchHelper();
+    }
+
+    /**
+     * Build card list and arrayadapter we need to fill with tasks
+     */
+    protected void buildCardListAndAdapter() {
+        mCards = new ArrayList<>();
+        mCardAdapter = new CardArrayRecyclerViewAdapter(mContext, mCards);
+        if (mCardRecyclerView != null) {
+            mCardRecyclerView.setAdapter(mCardAdapter);
+        }
+    }
+
+    private void setupItemTouchHelper() {
+        ItemTouchHelper touchHelper = new ItemTouchHelper(new ItemTouchHelper.Callback() {
+
+            RecentCard card;
+            int taskid;
+            int initPos;
+            int finalPos;
+            boolean isSwipe;
+            boolean unwantedDrag = true;
+
+            @Override
+            public boolean onMove(RecyclerView recyclerView, ViewHolder viewHolder, 
+                    ViewHolder target) {
+
+                /*we'll start multiwindow action in the clearView void, when the drag action 
+                and all animations are completed. Otherwise we'd do a loop action
+                till the drag is completed for each onMove (wasting resources and making
+                the drag not smooth).*/
+
+                initPos = viewHolder.getAdapterPosition();
+                card = (RecentCard) mCards.get(initPos);
+                taskid = card.getPersistentTaskId();
+
+                unwantedDrag = false;
+                return true;
+            }
+
+            @Override
+            public void onMoved (RecyclerView recyclerView, 
+                RecyclerView.ViewHolder viewHolder,
+                int fromPos,
+                RecyclerView.ViewHolder target,
+                int toPos,
+                int x,
+                int y) {
+
+                finalPos = toPos;
+                isSwipe = false;
+
+            }
+
+            @Override
+            public float getMoveThreshold (RecyclerView.ViewHolder viewHolder) {
+                //if less than this, we consider it as unwanted drag
+                return 0.5f;
+            }
+
+            @Override
+            public void clearView (RecyclerView recyclerView, 
+                RecyclerView.ViewHolder viewHolder) {
+                super.clearView(recyclerView, viewHolder);
+
+                if (isSwipe) {
+                    //don't start multiwindow on swipe
+                    return;
+                }
+
+                if (unwantedDrag) {
+                    /*this means MoveThreshold is less than needed, so onMove
+                    has not been considered, so we don't consider the action as wanted drag*/
+                    return;
+                }
+
+                unwantedDrag = true; //restore the drag check
+
+                //if a multiwin session is already active, ask the user to close it
+                int dockSide = WindowManagerProxy.getInstance().getDockSide();
+                if (dockSide != WindowManager.DOCKED_INVALID) {
+                    Toast mWarningToast = Toast.makeText(mContext, R.string.recents_multiwin_warning, Toast.LENGTH_LONG);
+                    mWarningToast.show();
+                    return;
+                }
+
+                ActivityOptions options = ActivityOptions.makeBasic();
+                /*Activity Manager let's dock the app to top or bottom dinamically, with the setDockCreateMode
+                DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT is 0, DOCKED_STACK_CREATE_MODE_BOTTOM_OR_RIGHT is 1
+                Thus if we drag down, dock app to bottom, if we drag up dock app to top*/
+                options.setDockCreateMode(finalPos > initPos ? 0 : 1);
+                options.setLaunchStackId(ActivityManager.StackId.DOCKED_STACK_ID);
+                try {
+                    card.hideCurrentOptions();//hide dragged card header longpress options
+                    ActivityManagerNative.getDefault()
+                            .startActivityFromRecents(taskid, options.toBundle());
+                    card = (RecentCard) mCards.get(finalPos);
+                    int newTaskid = card.getPersistentTaskId();
+                    /*after we docked our main app, on the other side of the screen we
+                    open the app we dragged the main app over*/
+                    mController.openOnDraggedApptoOtherSide(newTaskid);
+                } catch (RemoteException e) {}
+            }
+
+            @Override
+            public boolean isLongPressDragEnabled() {
+                return true;
+            }
+
+            @Override
+            public void onSwiped(ViewHolder viewHolder, int direction) {
+                int pos = viewHolder.getAdapterPosition();
+                RecentCard card = (RecentCard) mCards.get(pos);
+                mCards.remove(pos);
+                removeApplication(card.getTaskDescription());
+                mCardAdapter.notifyItemRemoved(pos);
+                isSwipe = true;
+            }
+
+            @Override
+            public int getMovementFlags(RecyclerView recyclerView,
+                    RecyclerView.ViewHolder viewHolder) {
+                // Set movement flags based on the layout manager
+                final int dragFlags = ItemTouchHelper.UP| ItemTouchHelper.DOWN;
+                final int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END;
+                return makeMovementFlags(dragFlags, swipeFlags);
+            }
+        });
+        touchHelper.attachToRecyclerView(mCardRecyclerView);
+    }
+
+    /**
+     * Assign the listeners to the card.
+     */
+    private RecentCard assignListeners(final RecentCard card, final TaskDescription td) {
+        if (DEBUG) Log.v(TAG, "add listeners to task card");
+
+        // Listen for onClick to start the app with custom animation
+        card.setOnClickListener(new Card.OnCardClickListener() {
+            @Override
+            public void onClick(Card card, View view) {
+                startApplication(td);
+            }
+        });
+
+        // App icon has own onLongClick action. Listen for it and
+        // process the favorite action for it.
+        card.addPartialOnLongClickListener(Card.CLICK_LISTENER_THUMBNAIL_VIEW,
+                new Card.OnLongCardClickListener() {
+            @Override
+            public boolean onLongClick(Card card, View view) {
+                RecentImageView favoriteIcon =
+                        (RecentImageView) view.findViewById(R.id.card_thumbnail_favorite);
+                favoriteIcon.setVisibility(td.getIsFavorite() ? View.INVISIBLE : View.VISIBLE);
+                handleFavoriteEntry(td);
+                return true;
+            }
+        });
+
+        // Listen for card is expanded to save current value for next recent call
+        card.setOnExpandAnimatorEndListener(new Card.OnExpandAnimatorEndListener() {
+            @Override
+            public void onExpandEnd(Card card) {
+                if (DEBUG) Log.v(TAG, td.getLabel() + " is expanded");
+                final int oldState = td.getExpandedState();
+                int state = EXPANDED_STATE_EXPANDED;
+                if ((oldState & EXPANDED_STATE_BY_SYSTEM) != 0) {
+                    state |= EXPANDED_STATE_BY_SYSTEM;
+                }
+                td.setExpandedState(state);
+            }
+        });
+        // Listen for card is collapsed to save current value for next recent call
+        card.setOnCollapseAnimatorEndListener(new Card.OnCollapseAnimatorEndListener() {
+            @Override
+            public void onCollapseEnd(Card card) {
+                if (DEBUG) Log.v(TAG, td.getLabel() + " is collapsed");
+                final int oldState = td.getExpandedState();
+                int state = EXPANDED_STATE_COLLAPSED;
+                if ((oldState & EXPANDED_STATE_BY_SYSTEM) != 0) {
+                    state |= EXPANDED_STATE_BY_SYSTEM;
+                }
+                td.setExpandedState(state);
+            }
+        });
+        return card;
+    }
+
+    /**
+     * Handle favorite task entry (add or remove) if user longpressed on app icon.
+     */
+    private void handleFavoriteEntry(TaskDescription td) {
+        ContentResolver resolver = mContext.getContentResolver();
+        final String favorites = Settings.System.getStringForUser(
+                    resolver, Settings.System.RECENT_PANEL_FAVORITES,
+                    UserHandle.USER_CURRENT);
+        String entryToSave = "";
+
+        if (!td.getIsFavorite()) {
+            if (favorites != null && !favorites.isEmpty()) {
+                entryToSave += favorites + "|";
+            }
+            entryToSave += td.identifier;
+        } else {
+            if (favorites == null) {
+                return;
+            }
+            for (String favorite : favorites.split("\\|")) {
+                if (favorite.equals(td.identifier)) {
+                    continue;
+                }
+                entryToSave += favorite + "|";
+            }
+            if (!entryToSave.isEmpty()) {
+                entryToSave = entryToSave.substring(0, entryToSave.length() - 1);
+            }
+        }
+
+        td.setIsFavorite(!td.getIsFavorite());
+
+        Settings.System.putStringForUser(
+                resolver, Settings.System.RECENT_PANEL_FAVORITES,
+                entryToSave,
+                UserHandle.USER_CURRENT);
+    }
+
+    /**
+     * Get application launcher label of installed references.
+     */
+    private String getApplicationLabel(String packageName) {
+        final PackageManager pm = mContext.getPackageManager();
+        final Intent intent = pm.getLaunchIntentForPackage(packageName);
+        final ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);
+        if (resolveInfo != null) {
+            return resolveInfo.activityInfo.loadLabel(pm).toString();
+        }
+        return null;
+    }
+
+    /**
+     * Remove requested application.
+     */
+    private void removeApplication(TaskDescription td) {
+        if (DEBUG) Log.v(TAG, "Jettison " + td.getLabel());
+
+        // Kill the actual app and send accessibility event.
+        final ActivityManager am = (ActivityManager)
+                mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        if (am != null) {
+            am.removeTask(td.persistentTaskId);
+
+            // Accessibility feedback
+            mCardRecyclerView.setContentDescription(
+                    mContext.getString(R.string.accessibility_recents_item_dismissed,
+                            td.getLabel()));
+            mCardRecyclerView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
+            mCardRecyclerView.setContentDescription(null);
+
+            // Remove app from task, cache and expanded state list.
+            removeApplicationBitmapCacheAndExpandedState(td);
+        }
+
+        // All apps were removed? Close recents panel.
+        if (mCards.size() == 0) {
+            setVisibility();
+            exit();
+        }
+    }
+
+    /**
+     * Remove all applications. Call from controller class
+     */
+    protected boolean removeAllApplications() {
+        final ActivityManager am = (ActivityManager)
+                mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        boolean hasFavorite = false;
+        int size = mCards.size() - 1;
+        for (int i = size; i >= 0; i--) {
+            RecentCard card = (RecentCard) mCards.get(i);;
+            TaskDescription td = card.getTaskDescription();
+            // User favorites are not removed.
+            if (td.getIsFavorite()) {
+                hasFavorite = true;
+                continue;
+            }
+            // Remove from task stack.
+            if (am != null) {
+                am.removeTask(td.persistentTaskId);
+            }
+            // Remove the card.
+            removeRecentCard(card);
+            // Remove bitmap and expanded state.
+            removeApplicationBitmapCacheAndExpandedState(td);
+        }
+        return !hasFavorite;
+    }
+
+    private void removeRecentCard(RecentCard card) {
+        int pos = mCards.indexOf(card);
+        mCards.remove(pos);
+        mCardAdapter.notifyItemRemoved(pos);
+    }
+
+    /**
+     * Remove application bitmaps from LRU cache and expanded state list.
+     */
+    private void removeApplicationBitmapCacheAndExpandedState(TaskDescription td) {
+        // Remove application thumbnail.
+        CacheController.getInstance(mContext)
+                .removeBitmapFromMemCache(String.valueOf(td.persistentTaskId));
+        // Remove application icon.
+        CacheController.getInstance(mContext)
+                .removeBitmapFromMemCache(td.identifier);
+        // Remove from expanded state list.
+        removeExpandedTaskState(td.identifier);
+    }
+
+    /**
+     * Start application or move to forground if still active.
+     */
+    protected void startApplication(TaskDescription td) {
+        // Starting app is requested by the user.
+        // Move it to foreground or start it with custom animation.
+        final ActivityManager am = (ActivityManager)
+                mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        if (td.taskId >= 0) {
+            // This is an active task; it should just go to the foreground.
+            am.moveTaskToFront(td.taskId, ActivityManager.MOVE_TASK_WITH_HOME,
+                    getAnimation(mContext, mMainGravity));
+        } else {
+            final Intent intent = td.intent;
+            intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY
+                    | Intent.FLAG_ACTIVITY_TASK_ON_HOME
+                    | Intent.FLAG_ACTIVITY_NEW_TASK);
+            if (DEBUG) Log.v(TAG, "Starting activity " + intent);
+            try {
+                mContext.startActivityAsUser(intent, getAnimation(mContext, mMainGravity),
+                        new UserHandle(UserHandle.USER_CURRENT));
+            } catch (SecurityException e) {
+                Log.e(TAG, "Recents does not have the permission to launch " + intent, e);
+            } catch (ActivityNotFoundException e) {
+                Log.e(TAG, "Error launching activity " + intent, e);
+            }
+        }
+        exit();
+    }
+
+    /**
+     * Get custom animation for app starting.
+     * @return Bundle
+     */
+    public static Bundle getAnimation(Context context, int gravity) {
+        return ActivityOptions.makeCustomAnimation(context,
+                gravity == Gravity.RIGHT ?
+                com.android.internal.R.anim.recent_screen_enter
+                : com.android.internal.R.anim.recent_screen_enter_left,
+                com.android.internal.R.anim.recent_screen_fade_out).toBundle();
+    }
+
+    /**
+     * Check if the requested store is in the task list to prevent it gets excluded.
+     */
+    private boolean storeIsInTaskList(String uriReference) {
+        if (mFirstTask != null && uriReference.equals(mFirstTask.packageName)) {
+            return true;
+        }
+        for (Card c : mCards) {
+            TaskDescription task = ((RecentCard) c).getTaskDescription();
+            if (uriReference.equals(task.packageName)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Create a TaskDescription, returning null if the title or icon is null.
+     */
+    private TaskDescription createTaskDescription(int taskId, int persistentTaskId,
+            Intent baseIntent, ComponentName origActivity,
+            CharSequence description, boolean isFavorite, int expandedState,
+            ActivityManager.TaskDescription td) {
+
+        final Intent intent = new Intent(baseIntent);
+        if (origActivity != null) {
+            intent.setComponent(origActivity);
+        }
+        final PackageManager pm = mContext.getPackageManager();
+        intent.setFlags((intent.getFlags()&~Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)
+                | Intent.FLAG_ACTIVITY_NEW_TASK);
+        final ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);
+        if (resolveInfo != null) {
+            final ActivityInfo info = resolveInfo.activityInfo;
+            String title = td.getLabel();
+            if (title == null) {
+                title = info.loadLabel(pm).toString();
+            }
+
+            String identifier = TASK_PACKAGE_IDENTIFIER;
+            final ComponentName component = intent.getComponent();
+            if (component != null) {
+                identifier += component.flattenToString();
+            } else {
+                identifier += info.packageName;
+            }
+
+            if (title != null && title.length() > 0) {
+                if (DEBUG) Log.v(TAG, "creating activity desc for id="
+                        + persistentTaskId + ", label=" + title);
+                int color = td.getPrimaryColor();
+
+                final TaskDescription item = new TaskDescription(taskId,
+                        persistentTaskId, resolveInfo, baseIntent, info.packageName,
+                        identifier, description, isFavorite, expandedState, color);
+                item.setLabel(title);
+                return item;
+            } else {
+                if (DEBUG) Log.v(TAG, "SKIPPING item " + persistentTaskId);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Load all tasks we want.
+     */
+    protected void loadTasks() {
+        if (isTasksLoaded() || mIsLoading) {
+            return;
+        }
+        if (DEBUG) Log.v(TAG, "loading tasks");
+        mIsLoading = true;
+        updateExpandedTaskStates();
+
+        // We have all needed tasks now.
+        // Let us load the cards for it in background.
+        final CardLoader cardLoader = new CardLoader();
+        cardLoader.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR);
+    }
+
+    /**
+     * Set correct visibility states for the listview and the empty recent icon.
+     */
+    private void setVisibility() {
+        mEmptyRecentView.setVisibility(mCards.size() == 0 ? View.VISIBLE : View.GONE);
+        mCardRecyclerView.setVisibility(mCards.size() == 0 ? View.GONE : View.VISIBLE);
+    }
+
+    /**
+     * We are holding a list of user expanded state of apps.
+     * Update the List for actual apps.
+     */
+    private void updateExpandedTaskStates() {
+        for (Card card : mCards) {
+            TaskDescription item = ((RecentCard) card).getTaskDescription();
+            boolean updated = false;
+            for (TaskExpandedStates expandedState : mExpandedTaskStates) {
+                if (item.identifier.equals(expandedState.getIdentifier())) {
+                    updated = true;
+                    expandedState.setExpandedState(item.getExpandedState());
+                }
+            }
+            if (!updated) {
+                mExpandedTaskStates.add(
+                        new TaskExpandedStates(
+                                item.identifier, item.getExpandedState()));
+            }
+        }
+    }
+
+    /**
+     * We are holding a list of user expanded state of apps.
+     * Get expanded state of the app.
+     */
+    private int getExpandedState(TaskDescription item) {
+        for (TaskExpandedStates oldTask : mExpandedTaskStates) {
+            if (DEBUG) Log.v(TAG, "old task launch uri = "+ oldTask.getIdentifier()
+                    + " new task launch uri = " + item.identifier);
+            if (item.identifier.equals(oldTask.getIdentifier())) {
+                    return oldTask.getExpandedState();
+            }
+        }
+        return EXPANDED_STATE_UNKNOWN;
+    }
+
+    /**
+     * We are holding a list of user expanded state of apps.
+     * Remove expanded state entry due that app was removed by the user.
+     */
+    private void removeExpandedTaskState(String identifier) {
+        TaskExpandedStates expandedStateToDelete = null;
+        for (TaskExpandedStates expandedState : mExpandedTaskStates) {
+            if (expandedState.getIdentifier().equals(identifier)) {
+                expandedStateToDelete = expandedState;
+            }
+        }
+        if (expandedStateToDelete != null) {
+            mExpandedTaskStates.remove(expandedStateToDelete);
+        }
+    }
+
+    protected void notifyDataSetChanged(boolean forceupdate) {
+        if (forceupdate || !mController.isShowing()) {
+            mCardAdapter.notifyDataSetChanged();
+        }
+    }
+
+    protected void setCancelledByUser(boolean cancelled) {
+        mCancelledByUser = cancelled;
+        if (cancelled) {
+            setTasksLoaded(false);
+        }
+    }
+
+    protected void setTasksLoaded(boolean loaded) {
+        mTasksLoaded = loaded;
+    }
+
+    protected boolean isCancelledByUser() {
+        return mCancelledByUser;
+    }
+
+    protected boolean isTasksLoaded() {
+        return mTasksLoaded;
+    }
+
+    protected void dismissPopup() {
+        for (Card card : mCards) {
+            card.hideOptions(-1, -1);
+        }
+    }
+
+    protected void setMainGravity(int gravity) {
+        mMainGravity = gravity;
+    }
+
+    protected void setScaleFactor(float factor) {
+        mScaleFactor = factor;
+    }
+
+    protected void setExpandedMode(int mode) {
+        mExpandedMode = mode;
+    }
+
+    protected void setShowTopTask(boolean enabled) {
+        mShowTopTask = enabled;
+    }
+
+    protected void setShowOnlyRunningTasks(boolean enabled) {
+        mOnlyShowRunningTasks = enabled;
+    }
+
+    protected boolean hasFavorite() {
+        for (Card card : mCards) {
+            TaskDescription td = ((RecentCard) card).getTaskDescription();
+            if (td.getIsFavorite()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    protected boolean hasClearableTasks() {
+        for (Card card : mCards) {
+            TaskDescription td = ((RecentCard) card).getTaskDescription();
+            if (!td.getIsFavorite()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Notify listener that tasks are loaded.
+     */
+    private void tasksLoaded() {
+        if (mOnTasksLoadedListener != null) {
+            mIsLoading = false;
+            if (!isCancelledByUser()) {
+                setTasksLoaded(true);
+                mOnTasksLoadedListener.onTasksLoaded();
+            }
+        }
+    }
+
+    /**
+     * Notify listener that we exit recents panel now.
+     */
+    private void exit() {
+        if (mOnExitListener != null) {
+            mOnExitListener.onExit();
+        }
+    }
+
+    protected void scrollToFirst() {
+        LinearLayoutManager lm = (LinearLayoutManager) mCardRecyclerView.getLayoutManager();
+        lm.scrollToPositionWithOffset(0, 0);
+    }
+
+    /**
+     * AsyncTask cardloader to load all cards in background. Preloading
+     * forces as well a card load or update. So if the user cancelled the preload
+     * or does not even open the recent panel we want to reduce the system
+     * load as much as possible. So we do it in background.
+     *
+     * Note: App icons as well the app screenshots are loaded in other
+     *       async tasks.
+     *       See #link:RecentCard, #link:RecentExpandedCard
+     *       #link:RecentAppIcon and #link AppIconLoader
+     */
+    private class CardLoader extends AsyncTask<Void, Void, Boolean> {
+
+        //private int mOrigPri;
+        private int mCounter;
+
+        public CardLoader() {
+        }
+
+        @Override
+        protected Boolean doInBackground(Void... params) {
+            Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
+
+            final int oldSize = mCards.size();
+            mCounter = 0;
+
+            // Check and get user favorites.
+            final String favorites = Settings.System.getStringForUser(
+                    mContext.getContentResolver(), Settings.System.RECENT_PANEL_FAVORITES,
+                    UserHandle.USER_CURRENT);
+            final ArrayList<String> favList = new ArrayList<>();
+            final ArrayList<TaskDescription> nonFavoriteTasks = new ArrayList<>();
+            if (favorites != null && !favorites.isEmpty()) {
+                for (String favorite : favorites.split("\\|")) {
+                    favList.add(favorite);
+                }
+            }
+
+            final PackageManager pm = mContext.getPackageManager();
+            final ActivityManager am = (ActivityManager)
+                    mContext.getSystemService(Context.ACTIVITY_SERVICE);
+
+            int maxNumTasksToLoad = Settings.System.getIntForUser(mContext.getContentResolver(),
+                    Settings.System.RECENTS_MAX_APPS, 15,
+                    UserHandle.USER_CURRENT);
+
+            final List<ActivityManager.RecentTaskInfo> recentTasks =
+                    am.getRecentTasksForUser(ActivityManager.getMaxRecentTasksStatic(),
+                    ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS
+                            | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK
+                            | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS
+                            | ActivityManager.RECENT_IGNORE_UNAVAILABLE
+                            | ActivityManager.RECENT_INCLUDE_PROFILES,
+                            UserHandle.CURRENT.getIdentifier());
+
+            final List<ActivityManager.RunningTaskInfo> runningTasks =
+                   am.getRunningTasks(Integer.MAX_VALUE);
+            final int numTasks = recentTasks.size();
+            int newSize = numTasks;
+            ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN)
+                    .addCategory(Intent.CATEGORY_HOME).resolveActivityInfo(pm, 0);
+
+            int firstItems = 0;
+            final int firstExpandedItems =
+                    mContext.getResources().getInteger(R.integer.expanded_items_default);
+
+            // Get current task list. We do not need to do it in background. We only load MAX_TASKS.
+            for (int i = 0; i < numTasks; i++) {
+                if (isCancelled() || mCancelledByUser) {
+                    if (DEBUG) Log.v(TAG, "loading tasks cancelled");
+                    mIsLoading = false;
+                    return false;
+                }
+
+                final ActivityManager.RecentTaskInfo recentInfo = recentTasks.get(i);
+
+                final Intent intent = new Intent(recentInfo.baseIntent);
+                if (recentInfo.origActivity != null) {
+                    intent.setComponent(recentInfo.origActivity);
+                }
+
+                boolean topTask = i == 0;
+                if (topTask) {
+                    ActivityManager.RunningTaskInfo rTask = getRunningTask(am);
+                    if (rTask != null) {
+                        if (!rTask.baseActivity.getPackageName().equals(
+                                recentInfo.baseIntent.getComponent().getPackageName())) {
+                            topTask = false;
+                        }
+                    }
+                }
+
+                if (mOnlyShowRunningTasks) {
+                    boolean isRunning = false;
+                    for (ActivityManager.RunningTaskInfo task : runningTasks) {
+                        if (recentInfo.baseIntent.getComponent().getPackageName().equals(
+                                task.baseActivity.getPackageName())) {
+                            isRunning = true;
+                        }
+                    }
+                    if (!isRunning) {
+                        newSize--;
+                        continue;
+                    }
+                 }
+
+                TaskDescription item = createTaskDescription(recentInfo.id,
+                        recentInfo.persistentId, recentInfo.baseIntent,
+                        recentInfo.origActivity, recentInfo.description,
+                        false, EXPANDED_STATE_UNKNOWN, recentInfo.taskDescription);
+
+                if (item != null) {
+                    // Remove any tasks after our max task limit to keep good ux
+                    if (i >= maxNumTasksToLoad) {
+                        am.removeTask(item.persistentTaskId);
+                        continue;
+                    }
+                    for (String fav : favList) {
+                        if (fav.equals(item.identifier)) {
+                            item.setIsFavorite(true);
+                            break;
+                        }
+                    }
+
+                    if (topTask) {
+                        if (mShowTopTask || screenPinningEnabled()) {
+                            // User want to see actual running task. Set it here
+                            int oldState = getExpandedState(item);
+                            if ((oldState & EXPANDED_STATE_TOPTASK) == 0) {
+                                oldState |= EXPANDED_STATE_TOPTASK;
+                            }
+                            item.setExpandedState(oldState);
+                            addCard(item, oldSize, true);
+                            mFirstTask = item;
+                        } else {
+                            // Skip the first task for our list but save it for later use.
+                           mFirstTask = item;
+                           newSize--;
+                        }
+                    } else {
+                        // FirstExpandedItems value forces to show always the app screenshot
+                        // if the old state is not known and the user has set expanded mode to auto.
+                        // On all other items we check if they were expanded from the user
+                        // in last known recent app list and restore the state. This counts as well
+                        // if expanded mode is always or never.
+                        int oldState = getExpandedState(item);
+                        if ((oldState & EXPANDED_STATE_BY_SYSTEM) != 0) {
+                            oldState &= ~EXPANDED_STATE_BY_SYSTEM;
+                        }
+                        if ((oldState & EXPANDED_STATE_TOPTASK) != 0) {
+                            oldState &= ~EXPANDED_STATE_TOPTASK;
+                        }
+                        if (DEBUG) Log.v(TAG, "old expanded state = " + oldState);
+                        if (firstItems < firstExpandedItems) {
+                            if (mExpandedMode != EXPANDED_MODE_NEVER) {
+                                oldState |= EXPANDED_STATE_BY_SYSTEM;
+                            }
+                            item.setExpandedState(oldState);
+                            // The first tasks are always added to the task list.
+                            addCard(item, oldSize, false);
+                        } else {
+                            if (mExpandedMode == EXPANDED_MODE_ALWAYS) {
+                                oldState |= EXPANDED_STATE_BY_SYSTEM;
+                            }
+                            item.setExpandedState(oldState);
+                            // Favorite tasks are added next. Non favorite
+                            // we hold for a short time in an extra list.
+                            if (item.getIsFavorite()) {
+                                addCard(item, oldSize, false);
+                            } else {
+                                nonFavoriteTasks.add(item);
+                            }
+                        }
+                        firstItems++;
+                    }
+                }
+            }
+
+            // Add now the non favorite tasks to the final task list.
+            for (TaskDescription item : nonFavoriteTasks) {
+                addCard(item, oldSize, false);
+            }
+
+            // We may have unused cards left. Eg app was uninstalled but present
+            // in the old task list. Let us remove them as well.
+            if (newSize < oldSize) {
+                for (int i = oldSize - 1; i >= newSize; i--) {
+                    if (DEBUG) Log.v(TAG,
+                            "loading tasks - remove not needed old card - position=" + i);
+                    mCards.remove(i);
+                }
+            }
+
+            return true;
+        }
+
+        private void addCard(TaskDescription task, int oldSize, boolean topTask) {
+            RecentCard card = null;
+
+            // We may have already constructed and inflated card.
+            // Let us reuse them and just update the content.
+            if (mCounter < oldSize) {
+                card = (RecentCard) mCards.get(mCounter);
+                if (card != null) {
+                    if (DEBUG) Log.v(TAG, "loading tasks - update old card");
+                    card.updateCardContent(task, mScaleFactor);
+                    card = assignListeners(card, task);
+                }
+                mCounter++;
+            }
+
+            // No old card was present to update....so add a new one.
+            if (card == null) {
+                if (DEBUG) Log.v(TAG, "loading tasks - create new card");
+                card = new RecentCard(mContext, task, mScaleFactor);
+                card = assignListeners(card, task);
+                mCards.add(card);
+            }
+        }
+
+        @Override
+        protected void onPostExecute(Boolean loaded) {
+            // If cancelled by system, log it and set task size
+            // to the only visible tasks we have till now to keep task
+            // removing alive. This should never happen. Just in case.
+            if (!loaded) {
+                Log.v(TAG, "card constructing was cancelled by system or user");
+            }
+
+            // Set correct view visibilitys
+            setVisibility();
+
+            // Notify arrayadapter that data set has changed
+            if (DEBUG) Log.v(TAG, "notifiy arrayadapter that data has changed");
+            notifyDataSetChanged(true);
+            // Notfiy controller that tasks are completly loaded.
+            tasksLoaded();
+        }
+    }
+
+    private ActivityManager.RunningTaskInfo getRunningTask(ActivityManager am) {
+        List<ActivityManager.RunningTaskInfo> tasks = am.getRunningTasks(1);
+        if (tasks != null && !tasks.isEmpty()) {
+            return tasks.get(0);
+        }
+        return null;
+    }
+
+    private boolean screenPinningEnabled() {
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.LOCK_TO_APP_ENABLED, 0) != 0;
+    }
+
+    /**
+     * We are holding a list of user expanded states of apps.
+     * This class describes one expanded state object.
+     */
+    private static final class TaskExpandedStates {
+        private String mIdentifier;
+        private int mExpandedState;
+
+        public TaskExpandedStates(String identifier, int expandedState) {
+            mIdentifier = identifier;
+            mExpandedState = expandedState;
+        }
+
+        public String getIdentifier() {
+            return mIdentifier;
+        }
+
+        public int getExpandedState() {
+            return mExpandedState;
+        }
+
+        public void setExpandedState(int expandedState) {
+            mExpandedState = expandedState;
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/TaskDescription.java b/packages/SystemUI/src/com/android/systemui/slimrecent/TaskDescription.java
new file mode 100644
index 00000000000..1a92c4a6cd2
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/TaskDescription.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2014-2016 SlimRoms Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.slimrecent;
+
+import android.content.Intent;
+import android.content.pm.ResolveInfo;
+
+public final class TaskDescription {
+    final ResolveInfo resolveInfo;
+    final int taskId; // application task id for curating apps
+    final int persistentTaskId; // persistent id
+    final Intent intent; // launch intent for application
+    final String packageName; // used to override animations (see onClick())
+    final String identifier;
+    final CharSequence description;
+    int cardColor = 0;
+
+    private String mLabel; // application package label
+    private int mExpandedState;
+    private boolean mIsFavorite;
+
+    public TaskDescription(int _taskId, int _persistentTaskId,
+            ResolveInfo _resolveInfo, Intent _intent,
+            String _packageName, String _identifier, CharSequence _description,
+            boolean isFavorite, int expandedState, int activityColor) {
+        resolveInfo = _resolveInfo;
+        intent = _intent;
+        taskId = _taskId;
+        persistentTaskId = _persistentTaskId;
+
+        description = _description;
+        packageName = _packageName;
+        identifier = _identifier;
+
+        mExpandedState = expandedState;
+        mIsFavorite = isFavorite;
+        cardColor = activityColor;
+    }
+
+    public TaskDescription() {
+        resolveInfo = null;
+        intent = null;
+        taskId = -1;
+        persistentTaskId = -1;
+
+        description = null;
+        packageName = null;
+        identifier = null;
+    }
+
+    public boolean isNull() {
+        return resolveInfo == null;
+    }
+
+    public String getLabel() {
+        return mLabel;
+    }
+
+    public void setLabel(String label) {
+        mLabel = label;
+    }
+
+    public int getExpandedState() {
+        return mExpandedState;
+    }
+
+    public void setExpandedState(int expandedState) {
+        mExpandedState = expandedState;
+    }
+
+    public boolean getIsFavorite() {
+        return mIsFavorite;
+    }
+
+    public void setIsFavorite(boolean isFavorite) {
+        mIsFavorite = isFavorite;
+    }
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/slimrecent/UserContentObserver.java b/packages/SystemUI/src/com/android/systemui/slimrecent/UserContentObserver.java
new file mode 100644
index 00000000000..bbe6ecb4ae5
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/slimrecent/UserContentObserver.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+package com.android.systemui.slimrecent;
+
+import android.app.ActivityManagerNative;
+import android.app.IUserSwitchObserver;
+import android.database.ContentObserver;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.IRemoteCallback;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * Simple extension of ContentObserver that also listens for user switch events to call update
+ */
+public abstract class UserContentObserver extends ContentObserver {
+    private static final String TAG = "UserContentObserver";
+
+    private Runnable mUpdateRunnable;
+
+    private IUserSwitchObserver mUserSwitchObserver = new IUserSwitchObserver.Stub() {
+        @Override
+        public void onUserSwitching(int newUserId, IRemoteCallback reply) {
+        }
+        @Override
+        public void onUserSwitchComplete(int newUserId) throws RemoteException {
+            mHandler.post(mUpdateRunnable);
+        }
+        @Override
+        public void onForegroundProfileSwitch(int newProfileId) {
+        }
+    };
+
+    private Handler mHandler;
+
+    /**
+     * Content observer that tracks user switches
+     * to allow clients to re-load settings for current user
+     */
+    public UserContentObserver(Handler handler) {
+        super(handler);
+        mHandler = handler;
+        mUpdateRunnable = new Runnable() {
+            @Override
+            public void run() {
+                update();
+            }
+        };
+    }
+
+    protected void observe() {
+        try {
+            ActivityManagerNative.getDefault().registerUserSwitchObserver(mUserSwitchObserver, TAG);
+        } catch (RemoteException e) {
+            Log.w(TAG, "Unable to register user switch observer!", e);
+        }
+    }
+
+    protected void unobserve() {
+        try {
+            mHandler.removeCallbacks(mUpdateRunnable);
+            ActivityManagerNative.getDefault().unregisterUserSwitchObserver(mUserSwitchObserver);
+        } catch (RemoteException e) {
+            Log.w(TAG, "Unable to unregister user switch observer!", e);
+        }
+    }
+
+    /**
+     *  Called to notify of registered uri changes and user switches.
+     *  Always invoked on the handler passed in at construction
+     */
+    protected void update(Uri uri) {
+        update();
+    }
+    protected abstract void update();
+
+    @Override
+    public void onChange(boolean selfChange, Uri uri) {
+        update(uri);
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
index 4866fca0591..1c452f90e6b 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
@@ -101,6 +101,7 @@ import com.android.systemui.SwipeHelper;
 import com.android.systemui.SystemUI;
 import com.android.systemui.assist.AssistManager;
 import com.android.systemui.recents.Recents;
+import com.android.systemui.slimrecent.RecentController;
 import com.android.systemui.statusbar.NotificationData.Entry;
 import com.android.systemui.statusbar.NotificationGuts.OnGutsClosedListener;
 import com.android.systemui.statusbar.phone.NavigationBarView;
@@ -190,6 +191,8 @@ public abstract class BaseStatusBar extends SystemUI implements
 
     protected boolean mDeviceInteractive;
 
+    protected RecentController mSlimRecents;
+
     protected boolean mVisible;
     protected ArraySet<Entry> mHeadsUpEntriesToRemoveOnSwitch = new ArraySet<>();
     protected ArraySet<Entry> mRemoteInputEntriesToRemoveOnCollapse = new ArraySet<>();
@@ -304,8 +307,38 @@ public abstract class BaseStatusBar extends SystemUI implements
 
             updateLockscreenNotificationSetting();
         }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            super.onChange(selfChange, uri);
+
+            if (uri.equals(Settings.System.getUriFor(
+                    Settings.System.USE_SLIM_RECENTS))) {
+                        updateRecents();
+            }
+        }
     };
 
+    protected void rebuildRecentsScreen() {
+        if (mSlimRecents != null) {
+            mSlimRecents.rebuildRecentsScreen();
+        }
+    }
+
+    protected void updateRecents() {
+        boolean slimRecents = Settings.System.getIntForUser(mContext.getContentResolver(),
+                Settings.System.USE_SLIM_RECENTS, 0, UserHandle.USER_CURRENT) == 1;
+
+        if (slimRecents) {
+            mSlimRecents = new RecentController(mContext, mLayoutDirection);
+            mRecents = null;
+            rebuildRecentsScreen();
+        } else {
+            mRecents = getComponent(Recents.class);
+            mSlimRecents = null;
+        }
+    }
+
     private final ContentObserver mLockscreenSettingsObserver = new ContentObserver(mHandler) {
         @Override
         public void onChange(boolean selfChange) {
@@ -734,7 +767,9 @@ public abstract class BaseStatusBar extends SystemUI implements
         mBarService = IStatusBarService.Stub.asInterface(
                 ServiceManager.getService(Context.STATUS_BAR_SERVICE));
 
-        mRecents = getComponent(Recents.class);
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.USE_SLIM_RECENTS), false,
+                        mSettingsObserver, UserHandle.USER_ALL);
 
         final Configuration currentConfig = mContext.getResources().getConfiguration();
         mLocale = currentConfig.locale;
@@ -746,6 +781,8 @@ public abstract class BaseStatusBar extends SystemUI implements
         mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
         mLockPatternUtils = new LockPatternUtils(mContext);
 
+        updateRecents();
+
         // Connect in to the status bar manager service
         mCommandQueue = new CommandQueue(this);
 
@@ -1334,6 +1371,8 @@ public abstract class BaseStatusBar extends SystemUI implements
 
     protected abstract View getStatusBarView();
 
+    /*this is not needed with DUI navbar because it's not set anymore in PhoneStatusBar and it preloads recents 
+    if the button has Recent action (SmartButtonView) with the ActionHandler. But i'm keeping it if anyone using stock navbar*/
     protected View.OnTouchListener mRecentsPreloadOnTouchListener = new View.OnTouchListener() {
         // additional optimization when we have software system buttons - start loading the recent
         // tasks on touch down
@@ -1375,18 +1414,25 @@ public abstract class BaseStatusBar extends SystemUI implements
 
     protected void hideRecents(boolean triggeredFromAltTab, boolean triggeredFromHomeKey) {
         if (mRecents != null) {
+        } else if (mSlimRecents != null) {
+            mSlimRecents.hideRecents(triggeredFromHomeKey);
             mRecents.hideRecents(triggeredFromAltTab, triggeredFromHomeKey);
         }
     }
 
     protected void toggleRecents() {
         if (mRecents != null) {
+        } else if (mSlimRecents != null) {
+            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
+            mSlimRecents.toggleRecents(mDisplay, mLayoutDirection, getStatusBarView());
             mRecents.toggleRecents(mDisplay);
         }
     }
 
     protected void preloadRecents() {
         if (mRecents != null) {
+        } else if (mSlimRecents != null) {
+            mSlimRecents.preloadRecentTasksList();
             mRecents.preloadRecents();
         }
     }
@@ -1401,6 +1447,8 @@ public abstract class BaseStatusBar extends SystemUI implements
 
     protected void cancelPreloadingRecents() {
         if (mRecents != null) {
+        } else if (mSlimRecents != null) {
+            mSlimRecents.cancelPreloadingRecentTasksList();
             mRecents.cancelPreloadingRecents();
         }
     }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java
index 328a3e65003..cde8d6e1f71 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardStatusBarView.java
@@ -26,6 +26,7 @@ import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.os.UserHandle;
 import android.provider.Settings;
+import android.os.UserHandle;
 import android.util.AttributeSet;
 import android.util.TypedValue;
 import android.view.MotionEvent;
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index 949b89bfe18..6b47e9d016e 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -1534,7 +1534,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
 
         @Override
         public boolean onLongClick(View v) {
-            if (mRecents == null || !ActivityManager.supportsMultiWindow()
+            if (!ActivityManager.supportsMultiWindow()
                     || !getComponent(Divider.class).getView().getSnapAlgorithm()
                             .isSplitScreenFeasible()) {
                 return false;
@@ -1548,11 +1548,19 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
 
     @Override
     protected void toggleSplitScreenMode(int metricsDockAction, int metricsUndockAction) {
-        if (mRecents == null) {
-            return;
-        }
-        int dockSide = WindowManagerProxy.getInstance().getDockSide();
-        if (dockSide == WindowManager.DOCKED_INVALID) {
+        if (mSlimRecents != null) {
+            int dockSide = WindowManagerProxy.getInstance().getDockSide();
+            if (dockSide == WindowManager.DOCKED_INVALID) {
+                mSlimRecents.startMultiWin();
+            } else {
+                EventBus.getDefault().send(new UndockingTaskEvent());
+                if (metricsUndockAction != -1) {
+                    MetricsLogger.action(mContext, metricsUndockAction);
+                }
+            }
+        } else if (mRecents != null) {
+            int dockSide = WindowManagerProxy.getInstance().getDockSide();
+            if (dockSide == WindowManager.DOCKED_INVALID) {
             if (!mOmniSwitchRecents) {
                 mRecents.dockTopTask(NavigationBarGestureHelper.DRAG_MODE_NONE,
                         ActivityManager.DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT, null, metricsDockAction);
@@ -1560,9 +1568,10 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
                 TaskUtils.dockTopTask(mContext);
             }
         } else {
-            EventBus.getDefault().send(new UndockingTaskEvent());
-            if (metricsUndockAction != -1) {
-                MetricsLogger.action(mContext, metricsUndockAction);
+                EventBus.getDefault().send(new UndockingTaskEvent());
+                if (metricsUndockAction != -1) {
+                    MetricsLogger.action(mContext, metricsUndockAction);
+                }
             }
         }
     }
@@ -5176,6 +5185,7 @@ public class PhoneStatusBar extends BaseStatusBar implements DemoMode,
     }
 
     public void showScreenPinningRequest(int taskId, boolean allowCancel) {
+        hideRecents(false, false);
         mScreenPinningRequest.showPrompt(taskId, allowCancel);
     }
 
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 040154557ac..dee25c25f44 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -2422,6 +2422,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
             case TYPE_STATUS_BAR_PANEL:
             case TYPE_STATUS_BAR_SUB_PANEL:
             case TYPE_SYSTEM_DIALOG:
+            case TYPE_SLIM_RECENTS:
             case TYPE_VOLUME_OVERLAY:
             case TYPE_PRIVATE_PRESENTATION:
             case TYPE_DOCK_DIVIDER:
@@ -2606,6 +2607,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         case TYPE_INPUT_CONSUMER:
             return 6;
         case TYPE_SYSTEM_DIALOG:
+        case TYPE_SLIM_RECENTS:
             return 7;
         case TYPE_TOAST:
             // toasts and the plugged-in battery thing
diff --git a/services/core/java/com/android/server/wm/WindowManagerService.java b/services/core/java/com/android/server/wm/WindowManagerService.java
index 7308b4944dd..bcbfa30d1cc 100644
--- a/services/core/java/com/android/server/wm/WindowManagerService.java
+++ b/services/core/java/com/android/server/wm/WindowManagerService.java
@@ -205,6 +205,7 @@ import static android.view.WindowManager.LayoutParams.TYPE_NAVIGATION_BAR;
 import static android.view.WindowManager.LayoutParams.TYPE_PHONE;
 import static android.view.WindowManager.LayoutParams.TYPE_PRIVATE_PRESENTATION;
 import static android.view.WindowManager.LayoutParams.TYPE_QS_DIALOG;
+import static android.view.WindowManager.LayoutParams.TYPE_SLIM_RECENTS;
 import static android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR;
 import static android.view.WindowManager.LayoutParams.TYPE_TOAST;
 import static android.view.WindowManager.LayoutParams.TYPE_VOICE_INTERACTION;
@@ -1868,7 +1869,7 @@ public class WindowManagerService extends IWindowManager.Stub
             case TYPE_STATUS_BAR:
             case TYPE_NAVIGATION_BAR:
             case TYPE_INPUT_METHOD_DIALOG:
-            case TYPE_PHONE:
+            case TYPE_SLIM_RECENTS:
                 return true;
         }
         return false;
-- 
2.12.0

